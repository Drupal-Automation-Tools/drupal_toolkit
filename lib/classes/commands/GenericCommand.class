<?php
/**
 * @file Provides the GenericCommand class.
 */

/**
 * Provides a basic implementation for commands, supporting most of the 
 * basic dependency injection functionality.
 */
abstract class GenericCommand implements RouterCommand {
  
  /**
   * DI for output.
   * 
   * @var OutputManagerInterface
   */
  private $output = NULL;
  
  /**
   * DI for arguments.
   * 
   * @var ArgsInterface
   */
  private $args = NULL;
  
  /**
   * DI for configuration.
   * 
   * @var ConfigurationManagerInterface
   */
  private $config = NULL;
  
  /**
   * DI for events.
   * 
   * @var EventManagerInterface
   */
  private $events = NULL;
  
  /**
   * DI for strings.
   * 
   * @var StringManagerInterface
   */
  private $sm = NULL;
  
  public function __construct() {}
  
  public function setStringManager(StringManagerInterface $sm) {
    $this->sm = $sm;
  }
  
  public function setEventManager(EventManagerInterface $event) {
    $this->events = $event;
  }
  
  public function setArgs(ArgsInterface $a) {
    $this->args = $a;
  }
  
  public function setOutput(OutputManagerInterface $output) {
    $this->output = $output;
  }
  
  public function setConfiguration(ConfigurationManagerInterface $c) {
    $this->config = $c;
  }
  
  public function verifyRequirements() {
    return TRUE;
  }
  
  public function verifyArguments() {
    return TRUE;
  }
  
  public function args() {
    return $this->args;
  }
  
  public function config() {
    return $this->config;
  }
  
  public function out() {
    return $this->output;
  }
  
  public function events() {
    return $this->events;
  }
  
  public function strings() {
    return $this->sm;
  }
  
  /**
   * Logs an error.
   * 
   * @param string $key
   *   A key for the string lookup.
   * @param array $args
   *   An array of keys for the string lookup.
   * @param int $level
   *   The log level (defaults to CLOG_ERROR).
   * @param string $default
   *   Fallback message should one not be found.
   */
  protected function error($key, $args = array(), $level = CLOG_ERROR, $default = NULL) {
    $this->out()->log($this->str($key, $args, $default), $level);
  }
  
  /**
   * Shows a working message to the user.
   * 
   * @param string $messageKey
   *   The message.
   * @param array $args
   *   Arguments to pass to the translation engine.
   */
  protected function showWork($messageKey, array $args = array()) {
    $this->out()->message($this->strings()->getString($messageKey, $args), MESSAGE_WORKING);
  }
  
  /**
   * Alias of GenericPlugin::showWork().
   */
  protected function working($messageKey, array $args = array()) {
    return $this->showWork($messageKey, $args);
  }
  
  /**
   * Shows a success message to the user.
   * 
   * @param string $messageKey
   *   The message.
   * @param array $args
   *   Arguments to pass to the translation engine.
   */
  protected function showSuccess($messageKey, array $args = array()) {
    $this->out()->message($this->strings()->getString($messageKey, $args), MESSAGE_SUCCESS);
  }
  
  
  /**
   * Alias of GenericPlugin::showSuccess().
   */
  protected function success($messageKey, array $args = array()) {
    return $this->showSuccess($messageKey, $args);
  }
  
  /**
   * Shows a failure message to the user.
   * 
   * @param string $messageKey
   *   The message.
   * @param array $args
   *   Arguments to pass to the translation engine.
   */
  protected function showFailure($messageKey, array $args = array()) {
    $this->out()->message($this->strings()->getString($messageKey, $args), MESSAGE_FAILURE);
  }
  
  /**
   * Alias of GenericPlugin::showFailure().
   */
  protected function failure($messageKey, array $args = array()) {
    return $this->showFailure($messageKey, $args);
  }
  
  /**
   * Wrapper around StringManagerInterface::getString().
   */
  protected function str($key, $args = array(), $default = NULL) {
    return $this->strings()->getString($key, $args, $default);
  }
  
  /**
   * Requires that the shell command be available.
   * 
   * @param string $commandName
   *   The command to require.
   * 
   * @return boolean
   *   TRUE if the command is available, otherwise false.
   */
  protected function requireCommand($commandName) {
    if (!shell_command_available($commandName)) {
      $this->error(STRING_ROUTER_NO_COMMAND, array(
        '!command' => $commandName,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * 
   * Requires that there be at least $pos arguments.
   * 
   * @param int $pos
   *   The argument position to require.
   * 
   * @return boolean
   *   TRUE if there are at least $pos arguments, otherwise FALSE.
   */
  protected function requireArgument($pos) {
    if (!$this->args()->hasArg($pos)) {
      $this->error(STRING_ROUTER_NO_ARGUMENT, array(
        '!count' => $pos,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Requires that the given configuration key is present.
   * 
   * @param string $key
   *   The configuration key to require.
   * 
   * @return boolean
   *   TRUE if the config key is present, otherwise FALSE.
   */
  protected function requireConfig($key) {
    $config = $this->config()->getConfig($key);
    if (empty($config)) {
      $this->error(STRING_ROUTER_NO_CONFIG, array(
        '!key' => $key,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Requires that the PHP function is available.
   * 
   * @param string $func_name
   *   The function name to check.
   * 
   * @return boolean
   *   TRUE if the function is present and enabled, otherwise FALSE.
   */
  protected function requireFunction($func_name) {
    if (!php_function_available($func_name)) {
      $this->error(STRING_ROUTER_NO_FUNCTION, array(
        '!function' => $func_name,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
}
