<?php
/**
 * @file Provides the GenericCommand class.
 */

/**
 * String token for when a system command is missing.
 * 
 * @ingroup strings
 */
define('STRING_ROUTER_NO_COMMAND', 'router.error.missing-command');

/**
 * String token for when not enough arguments were provided.
 * 
 * @ingroup strings
 */
define('STRING_ROUTER_NO_ARGUMENT', 'router.error.missing-argument');

/**
 * String token for when a configuration setting is missing.
 * 
 * @ingroup strings
 */
define('STRING_ROUTER_NO_CONFIG', 'router.error.missing-config');

/**
 * String token for when a PHP function is missing.
 * 
 * @ingroup strings
 */
define('STRING_ROUTER_NO_FUNCTION', 'router.error.missing-function');

/**
 * String token for when a command is not implemented.
 * 
 * @ingroup strings
 */
define('STRING_ROUTER_NO_IMPLEMENTATION', 'router.error.command-not-implemented');


/**
 * Provides a basic implementation for commands, supporting most of the 
 * basic dependency injection functionality.
 */
abstract class GenericCommand implements RouterCommand {
  
  private $output = NULL;
  
  private $args = NULL;
  
  private $config = NULL;
  
  private $events = NULL;
  
  private $sm = NULL;
  
  public function __construct() {
    
  }
  
  public function setStringManager(StringManagerInterface $sm) {
    $this->sm = $sm;
  }
  
  public function setEventManager(EventManagerInterface $event) {
    $this->events = $event;
  }
  
  public function setArgs(ArgsInterface $a) {
    $this->args = $a;
  }
  
  public function setOutput(OutputManagerInterface $output) {
    $this->output = $output;
  }
  
  public function setConfiguration(ConfigurationManagerInterface $c) {
    $this->config = $c;
  }
  
  public function verifyRequirements() {
    return TRUE;
  }
  
  public function verifyArguments() {
    return TRUE;
  }
  
  public function args() {
    return $this->args;
  }
  
  public function config() {
    return $this->config;
  }
  
  public function out() {
    return $this->output;
  }
  
  public function events() {
    return $this->events;
  }
  
  public function strings() {
    return $this->sm;
  }
  
  /**
   * Logs an error.
   * 
   * @param string $key
   *   A key for the string lookup.
   * @param array $args
   *   An array of keys for the string lookup.
   * @param int $level
   *   The log level (defaults to CLOG_ERROR).
   * @param string $default
   *   Fallback message should one not be found.
   */
  protected function error($key, $args = array(), $level = CLOG_ERROR, $default = NULL) {
    $message = $this->strings()->getString($key, $args, $default);
    $this->out()->log($message, $level);
  }
  
  /**
   * Requires that the shell command be available.
   * 
   * @param string $commandName
   *   The command to require.
   * 
   * @return boolean
   *   TRUE if the command is available, otherwise false.
   */
  protected function requireCommand($commandName) {
    if (!shell_command_available($commandName)) {
      $this->error(STRING_ROUTER_NO_COMMAND, array(
        '!command' => $commandName,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * 
   * Requires that there be at least $pos arguments.
   * 
   * @param int $pos
   *   The argument position to require.
   * 
   * @return boolean
   *   TRUE if there are at least $pos arguments, otherwise FALSE.
   */
  protected function requireArgument($pos) {
    if (!$this->args()->hasArg($pos)) {
      $this->error(STRING_ROUTER_NO_ARGUMENT, array(
        '!count' => $pos,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Requires that the given configuration key is present.
   * 
   * @param string $key
   *   The configuration key to require.
   * 
   * @return boolean
   *   TRUE if the config key is present, otherwise FALSE.
   */
  protected function requireConfig($key) {
    $config = $this->config()->getConfig($key);
    if (empty($config)) {
      $this->error(STRING_ROUTER_NO_CONFIG, array(
        '!key' => $key,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Requires that the PHP function is available.
   * 
   * @param string $func_name
   *   The function name to check.
   * 
   * @return boolean
   *   TRUE if the function is present and enabled, otherwise FALSE.
   */
  protected function requireFunction($func_name) {
    if (!php_function_available($func_name)) {
      $this->error(STRING_ROUTER_NO_FUNCTION, array(
        '!function' => $func_name,
      ));
      return FALSE;
    }
    return TRUE;
  }
  
}
