<?php
/**
 * @file Defines the EventManager class.
 */

/**
 * String token for when an event is fired.
 * 
 * @ingroup strings
 */
define('STRING_EVENT_FIRING', 'events.message.firing');

/**
 * Implements the EventManagerInterface.
 */
class EventManager implements EventManagerInterface,
        StringDependency {
  
  /**
   * An array of event listeners keyed by event type.
   * 
   * @var array.
   */
  private $registry = array();
  
  /**
   * The output manager.
   * 
   * @var OutputManagerInterface
   */
  private $out;
  
  /**
   * The string manager.
   * 
   * @var StringManager
   */
  private $sm;
  
  public function __construct() {
  }
  
  public function setOutput(OutputManagerInterface $out) {
    $this->out = $out;
  }
  
  public function setStringManager(StringManagerInterface $sm) {
    $this->sm = $sm;
  }
  
  public function strings() {
    return $this->sm;
  }
  
  public function out() {
    return $this->out;
  }
  
  public function registerListener($types, EventListener $listener) {
    if (!is_array($types)) {
      $types = array($types);
    }
    foreach ($types as $type) {
      if (!isset($this->registry[$type])) {
        $this->registry[$type] = array();
      }
      $this->registry[$type][] = $listener;
    }
    return TRUE;
  }
  
  public function dump() {
    foreach ($this->registry as $key => $list) {
      $listeners = array();
      foreach ($list as $listener) {
        $listeners[] = get_class($listener);
      }
      echo $key . ': ' . implode(",", $listeners) . PHP_EOL;
    }
  }
  
  public function fireEvent($type, DtkEvent &$context = NULL) {
    $this->out->debug('Firing event [' . $type . '].');
    if (empty($context)) {
      $context = new DtkEvent();
    }
    if (isset($this->registry[$type])) {
      foreach ($this->registry[$type] as $listener) {
        $listener->captureEvent($context, $type);
        if (!$context->checkContinueFiring()) {
          break;
        }
      }
    }
  }
  
}