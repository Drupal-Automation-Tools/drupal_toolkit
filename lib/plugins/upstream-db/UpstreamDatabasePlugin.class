<?php
/**
 * @file Provides the UpstreamDatabasePlugin class.
 */

/**
 * Responsible for downloading an upstream database and allowing some of the
 * settings to be preserved from the older version of the site.
 * 
 * @ingroup plugins
 */
class UpstreamDatabasePlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_UPSTREAM_IGNORE_UPSTREAM_TABLES_KEY => NULL,
      CONFIG_UPSTREAM_LOCAL_TABLES_KEY => NULL,
      CONFIG_UPSTREAM_GZIP_SUPPORT => FALSE,
      CONFIG_PRESERVE_VARIABLES => array(
        'cron_key',
        'drupal_private_key',
        'file_temporary_path',
        'background_process_token',
        'background_process_derived_default_host',
        'file_public_path',
      ),
    ));
    $this->events()->registerListener(array(
      EVENT_UPSTREAM_DATABASE_PRESERVE_STATE,
      EVENT_UPSTREAM_DATABASE_RESTORE_STATE,
      EVENT_UPSTREAM_PULL,
    ), $this);
  }
  
  public function captureEvent(DtkEvent &$context, $eventType) {
    switch ($eventType) {
      case EVENT_UPSTREAM_DATABASE_PRESERVE_STATE:
        if ($context->checkExecution()) {
          $state = $context->getVariable('state');
          $context->setResult($this->preserveVariablesTable($context->getVariable('alias'), $state));
          $context->setVariable('state', $state);
        }
        break;
      case EVENT_UPSTREAM_DATABASE_RESTORE_STATE:
        if ($context->checkExecution()) {
          $context->setResult($this->restoreVariablesTable($context->getVariable('alias'), $context->getVariable('state')));
        }
        break;
      case EVENT_UPSTREAM_PULL:
        if ($context->checkExecution()) {
          $context->setResult($this->syncUpstreamDatabases($context->getEntity(), $context->getUpstreamServer()));
        }
        break;
    }
  }
  
  /**
   * Retrieves the set of variables to be preserved during the update.
   * 
   * @param string $alias
   *   The drush alias of the site.
    unlink($upstreamDumpFile);
   * @param array $state
   *   The state array from the preserve state event.
   * 
   * @return boolean
   *   TRUE if the variables were all saved, otherwise FALSE.
   */
  private function preserveVariablesTable($alias, &$state) {
    $this->working(STRING_WORKING_PRESERVE_VARS);
    $variables = $this->config()->getConfig(CONFIG_PRESERVE_VARIABLES);
    if (!extra_empty($variables)) {
      $vars = array();
      foreach ($variables as $variable) {
        $this->working(STRING_WORKING_PRESERVE_VAR, array(
          '!var' => $variable,
        ));
        $vars[$variable] = drush_get_variable($variable, $alias);
      }
      $state['variables'] = $vars;
    }
    $this->success(STRING_SUCCESS_PRESERVE_VARS);
    return TRUE;
  }
  
  /**
   * Restores the set of variables that should be preserved during the update.
   * 
   * @param string $alias
   *   The drush alias of the site.
   * @param array $state
   *   The state array from the restore state event.
   * 
   * @return boolean
   *   TRUE if all the variables were set properly, otherwise FALSE.
   */
  private function restoreVariablesTable($alias, &$state) {
    $this->working(STRING_WORKING_RESTORE_VARS);
    if (!empty($state['variables'])) {
      foreach ($state['variables'] as $name => $value) {
        if ($value !== NULL) {
          $this->working(STRING_WORKING_RESTORE_VAR, array(
            '!var' => $name,
          ));
          if (!drush_set_variable($name, $value, $alias)) {
            $this->error(STRING_UPSTREAM_UNABLE_TO_RESTORE_VARIABLE, array(
              '!name' => $name,
              '!value' => $value,
            ));
            return FALSE;
          }
        }
      }
    }
    $this->success(STRING_SUCCESS_RESTORE_VARS);
    return TRUE;
  }
  
  /**
   * Creates a backup of the original database.
   * 
   * @param string $drushAlias
   *   Alias of a Drupal site.
   * @param string $database
   *   The database key to backup.
   * 
   * @return string
   *   The path to the backup file, or FALSE if the backup failed.
   */
  private function backupOriginalDatabase($drushAlias, $database) {
    $this->working(STRING_WORKING_UPSTREAM_DB_BACKUP);
    $ret = drush_db_dump($drushAlias, TRUE, array(
      'database' => $database,
    ));
    if ($ret) {
      $this->success(STRING_SUCCESS_UPSTREAM_DB_BACKUP);
    }
    else {
      $this->failure(STRING_FAILURE_UPSTREAM_DB_BACKUP);
    }
    return $ret;
  }
  
  /**
   * Restores the backup originally taken of the database.
   * 
   * @param string $drushAlias
   *   Alias of a Drupal site.
   * @param string $database
   *   Database key to restore to.
   * @param string $file
   *   The file to restore from as returned by backupOriginalDatabase().
   * 
   * @return boolean
   *   TRUe if the DB was restored, otherwise FALSe.
   */
  private function restoreOriginalDatabase($drushAlias, $database, $file) {
    $this->working(STRING_WORKING_UPSTREAM_DB_RESTORE);
    drush_drop_db($drushAlias, $database);
    $ret = drush_restore_db($file, $drushAlias, $database);
    if ($ret) {
      $this->success(STRING_SUCCESS_UPSTREAM_DB_RESTORE);
    }
    else {
      $this->failure(STRING_FAILURE_UPSTREAM_DB_RESTORE);
    }
    return $ret;
  }
  
  /**
   * Synchronizes this database with the upstream database.
   * 
   * This can include preserving some of the local data as well.
   * 
   * @param GenericDrupalEntity $site
   *   The site to sync.
   * @param PhysicalServerInterface $server
   * 
   * @return boolean
   *   TRUE if the sync was successful, otherwise FALSE.
   */
  private function syncUpstreamDatabases(GenericDrupalEntity $site, PhysicalServerInterface $server) {
    $this->working(STRING_WORKING_SYNC_DB);
    $keys = array(
      'default' => 'default',
    ) + $site->getSetting(SITE_DB_CONNECTION_KEYS);
    $drushAlias = $site->getDrushAlias(TRUE);
    foreach ($keys as $key) {
      $backup = $this->backupOriginalDatabase($drushAlias, $key);
      if (empty($backup)) {
        $this->error(STRING_UPSTREAM_UNABLE_TO_BACKUP_DATABASE);
        return FALSE;
      }
      if (!$this->syncUpstreamDatabase($server, $drushAlias, $key)) {
        if (!$this->restoreOriginalDatabase($drushAlias, $key, $backup)) {
          $this->error(STRING_UPSTREAM_UNABLE_TO_RESTORE_DATABASE, array(), CLOG_CRITICAL);
        }
        else {
          $this->error(STRING_ERROR_UPSTREAM_UNABLE_TO_DOWNLOAD_DB);
        }
        unlink($backup);
        return FALSE;
      }
      unlink($backup);
    }
    $this->success(STRING_SUCCESS_SYNC_DB);
    return TRUE;
  }
  
  /**
   * Synchronizes a specific database from the upstream server.
   * 
   * @param PhysicalServerInterface $server
   *   The upstream server.
   * @param string $localAlias
   *   Drush alias. Must be the same on both sites.
   * @param string $localDBKey
   *   Database key. Must be the same on both sites.
   * 
   * @return boolean
   *   TRUE if the database was synched properly, otherwise FALSE.
   */
  private function syncUpstreamDatabase(PhysicalServerInterface $server, $localAlias, $localDBKey) {
    $this->working(STRING_WORKING_SYNC_DB_ITEM, array(
      '!alias' => $localAlias,
      '!key' => $localDBKey,
    ));
    $upstreamDumpFile = $this->downloadUpstreamDatabase($server, $localAlias, $localDBKey);
    if (empty($upstreamDumpFile)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_DOWNLOAD_DUMP);
      return FALSE;
    }
    $localDumpFile = $this->generateLocalDatabaseDump($localAlias, $localDBKey);
    if ($localDumpFile === FALSE) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_CREATE_LOCAL_DUMP);
      unlink($upstreamDumpFile);
      return FALSE;
    }
    $context = new DtkEvent(TRUE, array(
      'alias' => $localAlias,
      'database' => $localDBKey,
      'remoteServer' => $server,
      'state' => array(),
    ));
    $this->working(STRING_WORKING_UPSTREAM_PRESERVE_STATE);
    $this->events()->fireEvent(EVENT_UPSTREAM_DATABASE_PRESERVE_STATE, $context);
    if (!$context->success()) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_PRESERVE_STATE);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    $this->working(STRING_WORKING_UPSTREAM_DROP_CURRENT);
    if (!drush_drop_db($localAlias, $localDBKey)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_DROP_CURRENT_DB);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    $this->working(STRING_WORKING_UPSTREAM_IMPORT_REMOTE);
    if (!drush_restore_db($upstreamDumpFile, $localAlias, $localDBKey)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_IMPORT_UPSTREAM_DB);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    if (!empty($localDumpFile)) {
      $this->working(STRING_WORKING_UPSTREAM_IMPORT_LOCAL);
      if (!drush_restore_db($localDumpFile, $localAlias, $localDBKey)) {
        $this->error(STRING_UPSTREAM_UNABLE_TO_IMPORT_LOCAL_DB);
        unlink($upstreamDumpFile);
        unlink($localDumpFile);
        return FALSE;
      }
    }
    $this->working(STRING_WORKING_UPSTREAM_RESTORE_STATE);
    $context2 = new DtkEvent(TRUE, array(
      'alias' => $localAlias,
      'database' => $localDBKey,
      'remoteServer' => $server,
      'state' => $context->getVariable('state', array()),
    ));
    $this->events()->fireEvent(EVENT_UPSTREAM_DATABASE_RESTORE_STATE, $context2);
    if (!$context2->success()) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_RESTORE_STATE);
    }
    else {
      $this->success(STRING_SUCCESS_SYNC_DB_ITEM);
      unlink($localDumpFile);
      unlink($upstreamDumpFile);
    }
    return $context2->success();
  }
  
  /**
   * Generates the local database dump.
   * 
   * @param string $alias
   *   Alias of a drupal site.
   * @param string $localDBKey
   *   Database connection key to use.
   * 
   * @return string
   *   Name of the local dump file. Could be FALSE if there was an error in
   *   creating the file. May also be NULL if there is no database dump 
   *   specified.
   */
  private function generateLocalDatabaseDump($alias, $localDBKey) {
    $tableKey = $this->config()->getConfig(CONFIG_UPSTREAM_LOCAL_TABLES_KEY);
    if (empty($tableKey)) {
      // Null indicates that we don't any relevant tables in the DB to dump.
      return NULL;
    }
    $this->working(STRING_WORKING_GENERATE_LOCAL_DUMP);
    $file = drush_db_dump($alias, TRUE, array(
      'database' => $localDBKey,
      'tables-key' => $tableKey,
    ));
    if (!empty($file)) {
      $this->success(STRING_SUCCESS_GENERATE_LOCAL_DUMP);
    }
    else {
      $this->failure(STRING_FAILURE_GENERATE_LOCAL_DUMP);
    }
    return $file;
  }
  
  /**
   * Downloads a dump of a remote database.
   * 
   * @param PhysicalServerInterface $server
   *   The server to dump from.
   * @param string $alias
   *   The drush alias to dump from.
   * @param string $localDBKey
   *   Database connection key to dump.
   * 
   * @return string
   *   Name of the upstream dump file on the local system or FALSE if there was
   *   an error generating the file.
   */
  private function downloadUpstreamDatabase(PhysicalServerInterface $server, $alias, $localDBKey) {
    $this->working(STRING_WORKING_GENERATE_REMOTE_DUMP);
    $ignoreKey = $this->config()->getConfig(CONFIG_UPSTREAM_IGNORE_UPSTREAM_TABLES_KEY);
    $command = 'drush @' . $alias . ' sql-dump --result-file --database=!db';
    $args = array(
      '!db' => $localDBKey,
      '!ignoreKey' => $ignoreKey,
    );
    if (!extra_empty($this->config()->getConfig(CONFIG_UPSTREAM_GZIP_SUPPORT))) {
      $command .= ' --gzip';
    }
    if (!extra_empty($ignoreKey)) {
      $command .= ' --skip-tables-key=!ignoreKey';
    }
    $out = array();
    $server->executeCommand($command, $args, $out);
    $file = FALSE;
    foreach ($out as $line) {
      $matches = array();
      if (preg_match('`Database dump saved to (.*)`i', $line, $matches)) {
        $file = reset($matches[1]);
      }
    }
    $path = $server->downloadFile($file);
    if (empty($path)) {
      $this->failure(STRING_FAILURE_GENERATE_REMOTE_DUMP);
    }
    else {
      $this->success(STRING_SUCCESS_GENERATE_REMOTE_DUMP);
    }
    return $path;
  }
  
}