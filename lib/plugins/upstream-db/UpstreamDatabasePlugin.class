<?php
/**
 * @file Provides the UpstreamDatabasePlugin class.
 */

/**
 * If there is a need to not download certain tables from the remote
 * server, set this config key to a key in $ignore_tables on the remote 
 * server.
 * 
 * You should also specify a mirrored value in CONFIG_UPSTREAM_LOCAL_TABLES_KEY
 * that specifies to keep all the ignored tables from the local install if
 * needed.
 * 
 * @ingroup config
 */
define('CONFIG_UPSTREAM_IGNORE_UPSTREAM_TABLES_KEY', 'upstream-ignore-upstream-tables-key');

/**
 * If there is a need to keep certain local tables from the previous installs,
 * set this config key to a key in $tables on the local server.
 * 
 * This data will be imported after the remote data is imported.
 * 
 * @ingroup config
 */
define('CONFIG_UPSTREAM_LOCAL_TABLES_KEY', 'upstream-local-tables-key');

/**
 * Set this config key to 1 in order to use gzip when downloading data.
 * 
 * Currently not supported.
 * 
 * @ingroup config
 */
define('CONFIG_UPSTREAM_GZIP_SUPPORT', 'upstream-gzip');

/**
 * If certain entries in the variables table should be preserved as they are,
 * add then to this array.
 * 
 * By default, several important variables are preserved in all cases:
 * - cron_key: This prevents the cron_key from being overridden on the local
 *   site and possibly breaking any existing crontab functionality. Also 
 *   prevents the server's cron_key from being known.
 * - drupal_private_key: Similar reasons to cron_key.
 * - file_temporary_path: As different servers might have different temp
 *   paths, this variable is not overridden.
 * - background_process_token: Specific to the background process module,
 *   this token should not be changed between installations.
 * - background-process_derived_default_host: Similar reasoning to the token.
 * 
 * Developers who know what they're doing can override these values directly
 * in this file if needed.
 * 
 * @ingroup config
 */
define('CONFIG_PRESERVE_VARIABLES', 'preserve-local-variables');

/**
 * String token for when the upstream database cannot be downloaded.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_DOWNLOAD_DUMP', 'upstream_db.error.unable-to-download');

/**
 * String token for when the local database dump fails.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_CREATE_LOCAL_DUMP', 'upstream_db.error.unable-to-create-local-dump');

/**
 * String token for when a plugin reports an error while saving the state.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_PRESERVE_STATE', 'upstream_db.error.unable-to-preserve-state');

/**
 * String token for when a plugin reports an error while restoring the state.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_RESTORE_STATE', 'upstream_db.error.unable-to-restore-state');

/**
 * String token for when the original database cannot be backed up.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_BACKUP_DATABASE', 'upstream_db.error.unable-to-backup-database');

/**
 * String token for when the original database could not be restored. This is a
 * fairly significant condition as it may indicate that the database is corrupt.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_RESTORE_DATABASE', 'upstream_db.warning.unable-to-restore-database');

/**
 * String token for if the database could not be dropped before the import.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_DROP_CURRENT_DB', 'upstream_db.error.unable-to-drop-current-db');

/**
 * String token for when the upstream database could not be imported.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_IMPORT_UPSTREAM_DB', 'upstream_db.error.unable-to-import-upstream');

/**
 * String token for when the local database could not be imported.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_IMPORT_LOCAL_DB', 'upstream_db.error.unable-to-import-local');

/**
 * String token for when a variable could not be restored to its original state.
 * 
 * @ingroup strings
 */
define('STRING_UPSTREAM_UNABLE_TO_RESTORE_VARIABLE', 'upstream_db.error.unable-to-restore-variable');

/**
 * This event is fired in order for plugins to obtain any information they need
 * to preserve from the Drupal site before the database is wiped out and replaced
 * by the upstream one. 
 * 
 * Plugins should use the $state proprty on the $context object to preserve
 * data between this event and EVENT_UPSTREAM_DATABASE_RESTORE_STATE.
 * 
 * Note that variable preservation is done by this plugin, see CONFIG_PRESERVE_VARIABLES.
 * 
 * @ingroup events
 */
define('EVENT_UPSTREAM_DATABASE_PRESERVE_STATE', 'upstream-db-preserve-state');

/**
 * This event is fired in order to restore the states preserved by 
 * EVENT_UPSTREAM_DATABASE_PRESERVE_STATE. Plugins should implement this event
 * in order to update the Drupal site with any preserved data.
 * 
 * An example of this can be seen in the variable presentation done by this
 * plugin.
 * 
 * @ingroup events
 */
define('EVENT_UPSTREAM_DATABASE_RESTORE_STATE', 'upstream-db-restore-state');

/**
 * Responsible for downloading an upstream database and allowing some of the
 * settings to be preserved from the older version of the site.
 */
class UpstreamDatabasePlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_UPSTREAM_IGNORE_UPSTREAM_TABLES_KEY => NULL,
      CONFIG_UPSTREAM_LOCAL_TABLES_KEY => NULL,
      CONFIG_UPSTREAM_GZIP_SUPPORT => FALSE,
      CONFIG_PRESERVE_VARIABLES => array(
        'cron_key',
        'drupal_private_key',
        'file_temporary_path',
        'background_process_token',
        'background_process_derived_default_host',
      ),
    ));
    $this->events()->registerListener(array(
      EVENT_UPSTREAM_DATABASE_PRESERVE_STATE,
      EVENT_UPSTREAM_DATABASE_RESTORE_STATE,
      EVENT_UPSTREAM_PULL,
    ), $this);
  }
  
  public function requiredPlugins() {
    return array('UpstreamPlugin');
  }
  
  public function captureEvent(&$context, $eventType) {
    switch ($eventType) {
      case EVENT_UPSTREAM_DATABASE_PRESERVE_STATE:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->preserveVariablesTable($context->alias, $context->state);
        }
        break;
      case EVENT_UPSTREAM_DATABASE_RESTORE_STATE:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->restoreVariablesTable($context->alias, $context->state);
        }
        break;
      case EVENT_UPSTREAM_PULL:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->syncUpstreamDatabases($context->site, $context->alias, $context->upstreamServer);
        }
        break;
    }
  }
  
  /**
   * Retrieves the set of variables to be preserved during the update.
   * 
   * @param string $alias
   *   The drush alias of the site.
   * @param array $state
   *   The state array from the preserve state event.
   * 
   * @return boolean
   *   TRUE if the variables were all saved, otherwise FALSE.
   */
  private function preserveVariablesTable($alias, &$state) {
    $variables = $this->config()->getConfig(CONFIG_PRESERVE_VARIABLES);
    if (!extra_empty($variables)) {
      $vars = array();
      foreach ($variables as $variable) {
        $vars[$variable] = drush_get_variable($variable, $alias);
      }
      $state['variables'] = $vars;
    }
    return TRUE;
  }
  
  /**
   * Restores the set of variables that should be preserved during the update.
   * 
   * @param string $alias
   *   The drush alias of the site.
   * @param array $state
   *   The state array from the restore state event.
   * 
   * @return boolean
   *   TRUE if all the variables were set properly, otherwise FALSE.
   */
  private function restoreVariablesTable($alias, &$state) {
    if (!empty($state['variables'])) {
      foreach ($state['variables'] as $name => $value) {
        if ($value !== NULL) {
          if (!drush_set_variable($name, $value, $alias)) {
            $this->error(STRING_UPSTREAM_UNABLE_TO_RESTORE_VARIABLE, array(
              '!name' => $name,
              '!value' => $value,
            ));
            return FALSE;
          }
        }
      }
    }
    return TRUE;
  }
  
  /**
   * Creates a backup of the original database.
   * 
   * @param string $drushAlias
   *   Alias of a Drupal site.
   * @param string $database
   *   The database key to backup.
   * 
   * @return string
   *   The path to the backup file, or FALSE if the backup failed.
   */
  private function backupOriginalDatabase($drushAlias, $database) {
    return drush_db_dump($drushAlias, TRUE, array(
      'database' => $database,
    ));
  }
  
  /**
   * Restores the backup originally taken of the database.
   * 
   * @param string $drushAlias
   *   Alias of a Drupal site.
   * @param string $database
   *   Database key to restore to.
   * @param string $file
   *   The file to restore from as returned by backupOriginalDatabase().
   * 
   * @return boolean
   *   TRUe if the DB was restored, otherwise FALSe.
   */
  private function restoreOriginalDatabase($drushAlias, $database, $file) {
    drush_drop_db($alias, $database);
    return drush_restore_db($file, $drushAlias, $database);
  }
  
  /**
   * Synchronizes this database with the upstream database.
   * 
   * This can include preserving some of the local data as well.
   * 
   * @param DrupalSite $site
   *   The site to sync.
   * 
   * @return boolean
   *   TRUE if the sync was successful, otherwise FALSE.
   */
  private function syncUpstreamDatabases(DrupalSite $site, $drushAlias, PhysicalServerInterface $server) {
    $keys = array(
      'default' => 'default',
    ) + $site->getSetting(SITE_DB_CONNECTION_KEYS);
    foreach ($keys as $key) {
      $backup = $this->backupOriginalDatabase($drushAlias, $key);
      if (empty($backup)) {
        $this->error(STRING_UPSTREAM_UNABLE_TO_BACKUP_DATABASE);
        return FALSE;
      }
      if (!$this->syncUpstreamDatabase($server, $drushAlias, $key)) {
        if (!$this->restoreOriginalDatabase($drushAlias, $key, $backup)) {
          $this->error(STRING_UPSTREAM_UNABLE_TO_RESTORE_DATABASE, array(), CLOG_CRITICAL);
        }
        unlink($backup);
        return FALSE;
      }
      unlink($backup);
    }
    return TRUE;
  }
  
  /**
   * Synchronizes a specific database from the upstream server.
   * 
   * @param PhysicalServerInterface $server
   *   The upstream server.
   * @param string $localAlias
   *   Drush alias. Must be the same on both sites.
   * @param string $localDBKey
   *   Database key. Must be the same on both sites.
   * 
   * @return boolean
   *   TRUE if the database was synched properly, otherwise FALSE.
   */
  private function syncUpstreamDatabase(PhysicalServerInterface $server, $localAlias, $localDBKey) {
    $upstreamDumpFile = $this->downloadUpstreamDatabase($server, $localAlias, $localDBKey);
    if (empty($upstreamDumpFile)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_DOWNLOAD_DUMP);
      return FALSE;
    }
    $localDumpFile = $this->generateLocalDatabaseDump($localAlias, $localDBKey);
    if ($localDumpFile === FALSE) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_CREATE_LOCAL_DUMP);
      unlink($upstreamDumpFile);
      return FALSE;
    }
    $context = (object) array(
      'alias' => $localAlias,
      'database' => $localDBKey,
      'remoteServer' => $server,
      'state' => array(),
      'handled' => FALSE,
      'success' => TRUE,
    );
    $this->events()->fireEvent(EVENT_UPSTREAM_DATABASE_PRESERVE_STATE, $context);
    if (empty($context->success)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_PRESERVE_STATE);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    
    if (!drush_drop_db($localAlias, $localDBKey)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_DROP_CURRENT_DB);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    
    if (!drush_restore_db($upstreamDumpFile, $localAlias, $localDBKey)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_IMPORT_UPSTREAM_DB);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    
    if (!empty($localDumpFile)) {
      if (!drush_restore_db($localDumpFile, $localAlias, $localDBKey)) {
        $this->error(STRING_UPSTREAM_UNABLE_TO_IMPORT_LOCAL_DB);
        unlink($upstreamDumpFile);
        unlink($localDumpFile);
        return FALSE;
      }
    }
    
    $context->handled = FALSE;
    $context->success = TRUE;
    $this->events()->fireEvent(EVENT_UPSTREAM_DATABASE_RESTORE_STATE, $context);
    if (empty($context->success)) {
      $this->error(STRING_UPSTREAM_UNABLE_TO_RESTORE_STATE);
      unlink($upstreamDumpFile);
      unlink($localDumpFile);
      return FALSE;
    }
    
    unlink($upstreamDumpFile);
    unlink($localDumpFile);
    return TRUE;
  }
  
  /**
   * Generates the local database dump.
   * 
   * @param string $alias
   *   Alias of a drupal site.
   * @param string $localDBKey
   *   Database connection key to use.
   * 
   * @return string
   *   Name of the local dump file. Could be FALSE if there was an error in
   *   creating the file. May also be NULL if there is no database dump 
   *   specified.
   */
  private function generateLocalDatabaseDump($alias, $localDBKey) {
    $tableKey = $this->config()->getConfig(CONFIG_UPSTREAM_LOCAL_TABLES_KEY);
    if (empty($tableKey)) {
      // Null indicates that we don't any relevant tables in the DB to dump.
      return NULL;
    }
    $file = drush_db_dump($alias, TRUE, array(
      'database' => $localDBKey,
      'tables-key' => $tableKey,
    ));
    return $file;
  }
  
  /**
   * Downloads a dump of a remote database.
   * 
   * @param PhysicalServerInterface $server
   *   The server to dump from.
   * @param string $alias
   *   The drush alias to dump from.
   * @param string $localDBKey
   *   Database connection key to dump.
   * 
   * @return string
   *   Name of the upstream dump file on the local system or FALSE if there was
   *   an error generating the file.
   */
  private function downloadUpstreamDatabase(PhysicalServerInterface $server, $alias, $localDBKey) {
    $ignoreKey = $this->config()->getConfig(CONFIG_UPSTREAM_IGNORE_UPSTREAM_TABLES_KEY);
    $command = 'drush @' . $alias . ' sql-dump --result-file --database=!db';
    $args = array(
      '!db' => $localDBKey,
      '!ignoreKey' => $ignoreKey,
    );
    if (!extra_empty($this->config()->getConfig(CONFIG_UPSTREAM_GZIP_SUPPORT))) {
      $command .= ' --gzip';
    }
    if (!extra_empty($ignoreKey)) {
      $command .= ' --skip-tables-key=!ignoreKey';
    }
    $out = array();
    $server->executeCommand($command, $args, $out);
    $file = FALSE;
    foreach ($out as $line) {
      $matches = array();
      if (preg_match('`Database dump saved to (.*)`i', $line, $matches)) {
        $file = reset($matches[1]);
      }
    }
    $path = $server->downloadFile($file);
    return $path;
  }
  
}