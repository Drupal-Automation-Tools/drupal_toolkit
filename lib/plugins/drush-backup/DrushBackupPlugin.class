<?php
/**
 * @file Defines the DrushBackupPlugin class.
 */

/**
 * Responsible for database backups using drush.
 * 
 * @ingroup plugins
 */
class DrushBackupPlugin extends GenericPlugin implements EventListener {

  /**
   * The name of the backups directory.
   * 
   * @var string
   */
  private static $backupDirectory = 'backups';
  
  /**
   * The name of the updates directory within $backupDirectory. This contains
   * the backups taken during updates.
   * 
   * @var string
   */
  private static $updateDirectory = 'updates';
  
  /**
   * The name of the reverted directory. This contains backups that were
   * reverted.
   * 
   * @var string
   */
  private static $revertedDirectory = 'reverted';
  
  /**
   * The name of the restored directory. This contains backups that were
   * restored.
   * 
   * @var string
   */
  private static $restoredDirectory = 'restored';
  
  public function initialize() {
    $this->events()->registerListener(array(
      EVENT_UPDATE_TAKE_BACKUP,
      EVENT_DELETE_BUILD,
      EVENT_ROLLBACK_BACKUP,
      EVENT_ROLLBACK_PHASE2,
      EVENT_UPDATE_TAKE_SUBSITE_BACKUP,
      EVENT_ROLLBACK_SUBSITES,
      EVENT_ROLLBACK_SUBSITE_PREP,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_DRUSH_BACKUP_STRUCTURE_ONLY => array(),
    ));
  }

  public function captureEvent(DtkEvent &$context, $eventType) {
    switch ($eventType) {
      case EVENT_UPDATE_TAKE_BACKUP:
        if ($context->checkExecution()) {
          $context->setResult($this->backupForUpdate($context->getSite()));
        }
        break;
      case EVENT_UPDATE_TAKE_SUBSITE_BACKUP:
        if ($context->checkExecution()) {
          $context->setResult($this->backupForUpdate($context->getSubSite()));
        }
        break;
      case EVENT_ROLLBACK_SUBSITE_PREP:
        if ($context->checkExecution()) {
          $context->setResult($this->backupForRollback($context->getSubSite(), $context->getVariable('currentBuild')));
        }
        break;
      case EVENT_ROLLBACK_BACKUP:
        if ($context->checkExecution()) {
          $context->setResult($this->backupForRollback($context->getSite(), $context->getVariable('currentBuild')));
        }
        break;
      case EVENT_ROLLBACK_SUBSITES:
        if ($context->checkExecution()) {
          $context->setResult($this->restoreFromBackup($context->getSubSite(), $context->getVariable('revertBuild')));
        }
        break;
      case EVENT_ROLLBACK_PHASE2:
        if ($context->checkExecution()) {
          $context->setResult($this->restoreFromBackup($context->getSite(), $context->getVariable('revertBuild')));
        }
        break;
      case EVENT_DELETE_BUILD:
        if ($context->checkExecution()) {
          $context->setResult($this->deleteBackup($context->getSite(), $context->getVariable('buildID')));
        }
        break;
    }
  }
  
  /**
   * Retrieves the list of database keys.
   * 
   * @param GenericDrupalEntity $entity
   *   The entity to get database keys for.
   * 
   * @return array
   *   An array of database keys to execute.
   */
  private function getDatabaseKeys(GenericDrupalEntity $entity) {
    return array(
      'default' => 'default',
    ) + $entity->getSetting(SITE_DB_CONNECTION_KEYS, array());
  }

  /**
   * Restores all the databases from a backup.
   * 
   * @param GenericDrupalEntity $site
   *   The site to restore backups for.
   * @param string $buildID
   *   ID to restore from.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  public function restoreFromBackup(GenericDrupalEntity $site, $buildID) {
    $drushAlias = $site->getSetting(SITE_DRUSH_ALIAS, NULL, TRUE);
    if (empty($drushAlias)) { return FALSE; }
    $this->working(STRING_WORKING_DRUSH_RESTORE, array(
      '!alias' => $drushAlias,
    ));
    $keys = $this->getDatabaseKeys($site);
    $backupDirectory = $this->getBackupDirectoryName($site, $buildID, self::$updateDirectory);
    $restoredDirectory = $this->getBackupDirectoryName($site, $buildID, self::$restoredDirectory, date('Ymd-his'));
    $ret = TRUE;
    foreach ($keys as $dbkey) {
      if (!$this->restoreDatabase($drushAlias, $dbkey, $backupDirectory, $restoredDirectory)) {
        $ret = FALSE;
        continue;
      }
    }
    if ($ret) {
      $this->success(STRING_SUCCESS_DRUSH_RESTORE);
    }
    return $ret;
  }
  
  /**
   * Restores a database for a given set of parameters.
   * 
   * @param string $drushAlias
   *   The drush alias to back up databases for.
   * @param string $dbkey
   *   The database key to back up.
   * @param string $backupDirectory
   *   The directory where update backups are kept.
   * @param string $restoreDirectory
   *   The directory where to save the backups after they've been restored.
   *  
   * @return boolean
   *   Whether or not the operation was successful.
   */
  private function restoreDatabase($drushAlias, $dbkey, $backupDirectory, $restoreDirectory) {
    $file = assemble_path($backupDirectory, $drushAlias . '-' . $dbkey . '.sql');
    $this->working(STRING_WORKING_DRUSH_RESTORE_ITEM, array(
      '!dbkey' => $dbkey,
      '!alias' => $drushAlias,
      '!file' => $file,
    ));    
    if (!is_readable($file)) {
      $this->warn(STRING_ERROR_COULD_NOT_RESTORE_BACKUP, array(
        '!db' => $dbkey,
        '!alias' => $drushAlias,
        '!file' => $file,
      ));
      return FALSE;
    }
    drush_drop_db($drushAlias, $dbkey);
    if (!drush_restore_db($file, $drushAlias, $dbkey)) {
      $this->error(STRING_ERROR_COULD_NOT_RESTORE_BACKUP, array(
        '!db' => $dbkey,
        '!alias' => $drushAlias,
        '!file' => $file,
      ), CLOG_CRITICAL);
      return FALSE;
    }
    else {
      $target = assemble_path($restoreDirectory, $drushAlias . '-' . $dbkey . '.sql');
      rename($file, $target);
    }
    return TRUE;
  }

  /**
   * Deletes all backups related to a given build ID.
   * 
   * @param DrupalSite $site
   *   Drupal site to delete backups from.
   * @param string $buildID
   *   Build ID to remove backups from.
   * 
   * @return boolean
   *   TRUE if all the backups were deleted, otherwise FALSE.
   */
  private function deleteBackup(DrupalSite $site, $buildID) {
    $this->working(STRING_WORKING_DRUSH_DELETE_BACKUPS, array(
      '!buildid' => $buildID
    ));
    $backupDirectory = assemble_path($site->getBuildFolder(), self::$backupDirectory, $buildID);
    if (is_dir($backupDirectory)) {
      remove_directory($backupDirectory);
    }
    if (is_dir($backupDirectory)) {
      $this->error(STRING_ERROR_COULD_NOT_DELETE_BACKUP);
      return FALSE;
    }
    $this->success(STRING_SUCCESS_DRUSH_DELETE_BACKUPS, array(
      '!buildid' => $buildID
    ));
    return TRUE;
  }


  /**
   * Backups the DB before a rollback.
   * 
   * @param GenericDrupalEntity $site
   *   Site to backup.
   * @param string $buildID
   *   Build ID to backup.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function backupForRollback(GenericDrupalEntity $site, $buildID) {
    return $this->executeDrushBackup($site, $buildID, self::$revertedDirectory);
  }
  
  /**
   * Backups the database before an update.
   * 
   * @param GenericDrupalEntity $entity
   *   The site to backup.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function backupForUpdate(GenericDrupalEntity $entity) {
    $buildID = NULL;
    if ($entity instanceof DrupalSubSite) {
      $buildID = $entity->getParentSite()->getPreviousBuildID();
    }
    else {
      $buildID = $entity->getPreviousBuildID();
    }
    return $this->executeDrushBackup($entity, $buildID, self::$updateDirectory);
  }
  
  /**
   * Retrieves the directory name of a backup directory.
   * 
   * @param GenericDrupalEntity $entity
   *   The entity to backup.
   * @param string $buildID
   *   The build ID to create a backup for.
   * @param string $targetDirectoryName
   *   Name of the target directory.
   * 
   * @return string
   *   The backup directory for $targetDirectoryName.
   */
  private function getBackupDirectoryName(GenericDrupalEntity $entity, $buildID, $backupType, $subDirectory = NULL) {
    $dir = assemble_path($entity->getBuildFolder(), self::$backupDirectory, $buildID, $backupType, $subDirectory);
    if (!is_dir($dir)) {
      mkdir_all($dir);
    }
    return $dir;
  }

  /**
   * Executes a drush backup command.
   * 
   * @param GenericDrupalEntity $entity
   *   The entity to backup.
   * @param string $buildID
   *   The build ID to create a backup for.
   * @param string $targetDirectoryName
   *   Name of the target directory.
   * 
   * @return boolean
   *   Whether or not the backup was successful.
   */
  private function executeDrushBackup(GenericDrupalEntity $entity, $buildID, $targetDirectoryName) {
    $this->working(STRING_WORKING_DRUSH_BACKUP);
    $drushAlias = $entity->getDrushAlias(TRUE);
    if (empty($drushAlias)) { return FALSE; }
    $keys = $this->getDatabaseKeys($entity);
    $directory = $this->getBackupDirectoryName($entity, $buildID, $targetDirectoryName);
    $gzip = !extra_empty($this->config()->getConfig(CONFIG_GZIP_SUPPORT));
    $structureOnlyTables = $this->config()->getConfig(CONFIG_DRUSH_BACKUP_STRUCTURE_ONLY);
    if (empty($structureOnlyTables)) {
      $structureOnlyTables = array();
    }
    foreach ($keys as $dbkey) {
      $this->working(STRING_WORKING_DRUSH_BACKUP_ITEM, array(
        '!dbkey' => $dbkey,
      ));
      $file = assemble_path($directory, $drushAlias . '-' . $dbkey . '.sql');
      if (!drush_db_dump($drushAlias, $file, array(
            'database' => $dbkey,
            'gzip' => $gzip,
            'structure-tables-key' => $structureOnlyTables,
      ))) {
        $this->error(STRING_COULD_NOT_BACKUP_DB);
        return FALSE;
      }
    }
    $this->success(STRING_SUCCESS_DRUSH_BACKUP);
    return TRUE;
  }

}
