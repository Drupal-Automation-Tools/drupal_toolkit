<?php
/**
 * @file Defines the DrushBackupPlugin class.
 */

/**
 * String token for when we are unable to backup the database.
 * 
 * @ingroup strings
 */
define('STRING_COULD_NOT_BACKUP_DB', 'drush_backup.error.no-db-backup');

/**
 * String token for when we are unable to delete the DB backup.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_COULD_NOT_DELETE_BACKUP', 'drush_backup.error.delete-backup');

/**
 * String token for when the toolkit could not restore from backups.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_COULD_NOT_RESTORE_BACKUP', 'drush_backup.error.restore-error');

/**
 * String token for when the toolkit is about to restore from backups.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_DRUSH_RESTORE', 'drush_backup.working.restore');

/**
 * String token for when the toolkit is about to restore an item from backups.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_DRUSH_RESTORE_ITEM', 'drush_backup.working.restore-item');

/**
 * String token for when the toolkit is done restoring from backups.
 * 
 * @ingroup strings
 */
define('STRING_SUCCESS_DRUSH_RESTORE', 'drush_backup.success.restore');

/**
 * String token for when the toolkit is deleting backups.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_DRUSH_DELETE_BACKUPS', 'drush_backup.working.delete');

/**
 * String token for when the toolkit is done deleting backups.
 * 
 * @ingroup strings
 */
define('STRING_SUCCESS_DRUSH_DELETE_BACKUPS', 'drush_backup.success.delete');

/**
 * String token for when the toolkit is backing up the databases.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_DRUSH_BACKUP', 'drush_backup.working.backup');

/**
 * String token for when the toolkit is backing up a specific database.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_DRUSH_BACKUP_ITEM', 'drush_backup.working.backup-item');

/**
 * String token for when the toolkit has finished backing up all the databases
 */
define('STRING_SUCCESS_DRUSH_BACKUP', 'drush_backup.success.backup');

/**
 * Responsible for database backups using drush.
 */
class DrushBackupPlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $this->events()->registerListener(array(
      EVENT_UPDATE_TAKE_BACKUP,
      EVENT_DELETE_BUILD,
      EVENT_ROLLBACK_BACKUP,
      EVENT_ROLLBACK_PHASE2,
    ), $this);
  }
  
  public function captureEvent(&$context, $eventType) {
    switch ($eventType) {
      case EVENT_ROLLBACK_BACKUP:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->backupForRollback($context->site, $context->currentBuild);
        }
        break;
      case EVENT_ROLLBACK_PHASE2:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->restoreFromBackup($context->site, $context->revertBuild);
        }
        break;
      case EVENT_UPDATE_TAKE_BACKUP:
        $context->success = $this->drushBackup($context->site);
        $context->stopPropagation = TRUE;
        break;
      case EVENT_DELETE_BUILD:
        if (empty($context->handled) || $context->success) {
          $context->success = $this->deleteBackup($context->site, $context->buildID);
          $context->handled = TRUE;
        }
        break;
    }
  }
  
  public function requiredPlugins() {
    return array('DrupalSitePlugin', 'DrushConfigurationPlugin', 'DatabaseConfigurationPlugin');
  }
  
  /**
   * Restores all the databases from a backup.
   * 
   * @param DrupalSite $site
   *   The site to restore backups for.
   * @param string $buildID
   *   ID to restore from.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  public function restoreFromBackup(DrupalSite $site, $buildID) {
    $drushAlias = $site->getSetting(SITE_DRUSH_ALIAS);
    if (empty($drushAlias)) {
      $this->error(STRING_SITE_MISSING_SETTING, array(
        '!key' => SITE_DRUSH_ALIAS,
      ));
      return FALSE;
    }
    $this->working(STRING_WORKING_DRUSH_RESTORE);
    $keys = array(
      'default' => 'default',
    ) + $site->getSetting(SITE_DB_CONNECTION_KEYS);
    $backupDirectory = assemble_path($site->getBuildFolder(), 'backups', $buildID, 'updates');
    $restoredDirectory = assemble_path($site->getBuildFolder(), 'restored', $buildID, date('Ymd-his'));
    if (!is_dir($restoredDirectory)) {
      mkdir_all($restoredDirectory);
    }
    $ret = TRUE;
    foreach ($keys as $dbkey) {
      $file = assemble_path($backupDirectory, $dbkey . '.sql');
      $this->working(STRING_WORKING_DRUSH_RESTORE_ITEM, array(
        '!dbkey' => $dbkey,
        '!file' => $file,
      ));
      drush_drop_db($drushAlias, $dbkey);
      if (!drush_restore_db($file, $drushAlias, $dbkey)) {
        $this->warn(STRING_ERROR_COULD_NOT_RESTORE_BACKUP, array(
          '!db' => $dbkey,
          '!alias' => $drushAlias,
          '!file' => $file,
        ));
        $ret = FALSE;
      }
      else {
        $target = assemble_path($restoredDirectory, $dbkey . '.sql');
        rename($file, $target);
      }
    }
    $this->success(STRING_SUCCESS_DRUSH_RESTORE);
    return $ret;
  }
  
  /**
   * Backups up the DB before a rollback.
   * 
   * @param DrupalSite $site
   *   Site to backup.
   * @param string $buildID
   *   Build ID to backup.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function backupForRollback(DrupalSite $site, $buildID) {
    return $this->drushBackup($site, 'reverted', $buildID);
  }
  
  /**
   * Deletes all backups related to a given build ID.
   * 
   * @param DrupalSite $site
   *   Drupal site to delete backups from.
   * @param string $buildID
   *   Build ID to remove backups from.
   * 
   * @return boolean
   *   TRUE if all the backups were deleted, otherwise FALSE.
   */
  private function deleteBackup(DrupalSite $site, $buildID) {
    $this->working(STRING_WORKING_DRUSH_DELETE_BACKUPS, array(
      '!buildid' => $buildID
    ));
    $backupDirectory = assemble_path($site->getBuildFolder(), 'backups', $buildID);
    if (is_dir($backupDirectory)) {
      remove_directory($backupDirectory);
    }
    if (is_dir($backupDirectory)) {
      $this->error(STRING_ERROR_COULD_NOT_DELETE_BACKUP);
      return FALSE;
    }
    $this->success(STRING_SUCCESS_DRUSH_DELETE_BACKUPS, array(
      '!buildid' => $buildID
    ));
    return TRUE;
  }
  
  /**
   * Takes a backup of a site's database using Drush.
   * 
   * @param DrupalSite $site
   *   The site to take a backup of.
   * 
   * @return boolean
   *   Whether or not the backup was successful.
   */
  private function drushBackup(DrupalSite $site, $type = 'updates', $buildID = NULL) {
    if (empty($buildID)) {
      $buildID = $site->getBuildID();
    }
    $drushAlias = $site->getSetting(SITE_DRUSH_ALIAS);
    if (empty($drushAlias)) {
      $this->error(STRING_SITE_MISSING_SETTING, array(
        '!key' => SITE_DRUSH_ALIAS,
      ));
      return FALSE;
    }
    $this->working(STRING_WORKING_DRUSH_BACKUP);
    $keys = array(
      'default' => 'default',
    ) + $site->getSetting(SITE_DB_CONNECTION_KEYS);
    $backupDirectory = assemble_path($site->getBuildFolder(), 'backups', $buildID, $type);
    if (!is_dir($backupDirectory)) {
      mkdir_all($backupDirectory);
    }
    foreach ($keys as $dbkey) {
      $this->working(STRING_WORKING_DRUSH_BACKUP_ITEM, array(
        '!dbkey' => $dbkey,
      ));
      $file = assemble_path($backupDirectory, $dbkey . '.sql');
      if (!drush_db_dump($drushAlias, $file, array(
        'database' => $dbkey,
      ))) {
        $this->error(STRING_COULD_NOT_BACKUP_DB);
        return FALSE;
      }
    }
    $this->success(STRING_SUCCESS_DRUSH_BACKUP);
    return TRUE;
  }  
  
}