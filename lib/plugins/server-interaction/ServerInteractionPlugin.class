<?php
/**
 * @file Defines the ServerInteractionPlugin class.
 * 
 * @defgroup server_settings "Server Settings"
 * Settings that can be define for server definitions.
 * 
 * @defgroup server_types "Server Types"
 * The different types of servers that can be defined underneath the si-servers
 * key. Each class of server is an array of @ref server_settings "server settings"
 * that define how the server is handled.
 * 
 * @defgroup server_connection_types "Remote Connection Types"
 * Different types of remote connections that can be made.
 * 
 * @defgroup server_implementation_types "Server Implementation Types"
 * Different ways of implementing connections to remote machines. Defaults to 
 * a standard implementation named RemoteMachine. Other plugins can support 
 * other methods of interacting with this server.
 */

/**
 * Fired when a list of servers are needed.
 * 
 * @ingroup events
 */
define('EVENT_FIND_SERVERS', 'find-servers');

/**
 * Config key for the list of servers.
 * 
 * This key must be defined via YAML and be a list of @ref server_types 
 * "server types". 
 * 
 * @ingroup config
 */
define('CONFIG_SERVER_LIST', 'si-servers');

/**
 * String token for when there is an error connecting to the server.
 * 
 * @ingroup strings
 */
define('STRING_SERVER_INTERACTION_NO_SERVER', 'server_interaction.error.could-not-init');

/**
 * Site setting for external files.
 * 
 * This is an array of files managed through PhysicalServerInterface objects
 * that should be tied to this Drupal site (eg deleted).
 * 
 * @ingroup site_settings
 */
define('SITE_REMOTE_FILES', 'remote-files');

/**
 * Server setting for the type of remote server object to build.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_TYPE', 'server-implementation');

/**
 * Generic server implementation - this is the default.
 * 
 * @ingroup server_implementation_types
 */
define('SERVER_IMPLEMENTATION_GENERIC', 'generic');

/**
 * Fired when we need a physical server type.
 * 
 * @ingroup events
 */
define('EVENT_CAST_PHYSICAL_SERVER', 'cast-physical-server');

/**
 * String token for when we are unable to delete a managed remote file.
 * 
 * @ingroup strings
 */
define('STRING_UNABLE_TO_DELETE_REMOTE_FILE', 'server_interaction.error.could-not-delete-remote-file');

/**
 * String token for when the server could not be cast.
 * 
 * @ingroup strings
 */
define('STRING_UNABLE_TO_CAST_SERVER', 'server_interaction.error.unable-to-cast');

/**
 * Manages the list of the different types of servers that can be used by
 * various plugins.
 */
class ServerInteractionPlugin extends GenericPlugin implements EventListener {
    
  /**
   * An array of servers, keyed by type.
   * 
   * @var array
   */
  private $servers = array();
  
  public function initialize() {
    $files = array(
      'PhysicalServerInterface.iface',
      'GenericMachine.class',
      'LocalMachine.class',
      'RemoteMachine.class',
    );
    $root = dirname(__FILE__);
    foreach ($files as $file) {
      require assemble_path($root, $file);
    }
    $this->events()->registerListener(array(
      EVENT_FIND_SERVERS,
      EVENT_REMOVE_ALL,
      EVENT_CAST_PHYSICAL_SERVER,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_SERVER_LIST => array(),
    ));
  }
  
  /**
   * Retrieves a list of servers of the given type. 
   * 
   * @param string $type
   *   One of the @ref server_types "server types".
   * @param boolean $noLocal
   *   If set to TRUE, the local system will not be considered one of the
   *   servers.
   * 
   * @return array
   *   An array of PhysicalServerInterface objects.
   */
  private function loadServersOfType($type, $noLocal = FALSE) {
    if (empty($this->servers[$type])) {
      $servers = array();
      $allServers = $this->config()->getConfig(CONFIG_SERVER_LIST);
      if (!empty($allServers)) {
        if (isset($allServers[$type])) {
          foreach ($allServers[$type] as $key => $serverConfiguration) {
            $context = (object) array(
              'settings' => $serverConfiguration,
              'server' => NULL,
              'type' => NULL,
            );
            if (!empty($serverConfiguration[SERVER_SETTING_TYPE])) {
              $context->type = $serverConfiguration[SERVER_SETTING_TYPE];
            }
            if (empty($context->type)) {
              // Default for old behaviour
              $context->server = new RemoteMachine($serverConfiguration);
            }
            else {
              // New support
              $this->events()->fireEvent(EVENT_CAST_PHYSICAL_SERVER, $context);
              if (empty($context->server)) {
                $this->warn(STRING_UNABLE_TO_CAST_SERVER, array(
                  '!type' => $context->type,
                ));
                continue;
              }
            }
            if ($context->server->initialize()) {
              $servers[$key] = $context->server;
            }
            else {
              $this->error(STRING_SERVER_INTERACTION_NO_SERVER, array(
                '!key' => $key,
              ));
            }
          }
        }
      }
      if ((!$noLocal) && extra_empty($this->config()->getConfig('si-disable-local-' . $type))) {
        $servers[] = new LocalMachine();
      }
      $this->servers[$type] = $servers;
    }
    return $this->servers[$type];
  }
  
  /**
   * Deletes all remote files managed by plugins that report their files.
   * 
   * @param DrupalSite $site
   *   The site to delete remote files for.
   * 
   * @return boolean
   *   If all remote files were deleted without a problem.
   */
  private function deleteRemoteFiles(DrupalSite $site) {
    $remoteFiles = $site->getSetting(SITE_REMOTE_FILES);
    // protect against this variable not being initialized yet
    if (empty($remoteFiles)) {
      return TRUE;
    }
    $r = TRUE;
    foreach ($remoteFiles as $remote) {
      if ($remote['server'] instanceof PhysicalServerInterface) {
        if (!$remote['server']->initialize()) {
          $this->warn(STRING_SERVER_INTERACTION_NO_SERVER);
          $r = FALSE;
        }
        elseif (!$remote['server']->deleteFile($remote['file'])) {
          $this->warn(STRING_UNABLE_TO_DELETE_REMOTE_FILE);
          $r = FALSE;
        }
      }
      else {
        $this->warn(STRING_SERVER_INTERACTION_NO_SERVER);
        $r = FALSE;
      }
    }
    return $r;
  }
  
  /**
   * Casts remote servers based on their type.
   * 
   * @param string $serverSettings
   *   The server settings array.
   * @param string $type
   *   The server type.
   * 
   * @return PhysicalServerInterface
   *   The server object, or NULL if the type is not supported.
   */
  private function castRemoteServer($serverSettings, $type) {
    switch ($type) {
      case SERVER_IMPLEMENTATION_GENERIC:
        return new RemoteMachine($serverSettings);
    }
    return NULL;
  }
  
  public function captureEvent(&$context, $type) {
    switch ($type) {
      case EVENT_CAST_PHYSICAL_SERVER:
        if (empty($context->server)) {
          $context->server = $this->castRemoteServer($context->settings, $context->type);
        }
        break;
      case EVENT_FIND_SERVERS:
        $context->servers = array_merge($context->servers, $this->loadServersOfType($context->serverType, isset($context->skipLocal) ? $context->skipLocal : TRUE));
        break;
      case EVENT_REMOVE_ALL:
        $context->success = $this->deleteRemoteFiles($context->site) && $context->success;
        break;
    }
  }
  
}