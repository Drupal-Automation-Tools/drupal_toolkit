<?php
/**
 * @file Defines the HostsConfigurationPlugin class.
 * 
 * @defgroup managed_host_types "Managed Host Server Types"
 * The different types of managed hosts that can be set. 
 */

/**
 * Config key for whether or not the local server needs its host file 
 * managed.
 */
define('CONFIG_MANAGED_HOSTS_USE_LOCAL', 'managed-host-local');

/**
 * Config key for the fallback type for managed host servers.
 * 
 * @see @ref managed_host_types "Managed Host Types"
 * @ingroup config
 */
define('CONFIG_MANAGED_HOSTS_DEFAULT_TYPE', 'managed-host-default-type');

/**
 * Config key for the target IP address for host files.
 * 
 * @ingroup config
 */
define('CONFIG_MANAGED_HOSTS_TARGET_IP_ADDRESS', 'managed-host-ip-address');

/**
 * Config key to prevent the hosts files from being updated during the site
 * update process.
 * 
 * @ingroup config
 */
define('CONFIG_MANAGED_HOSTS_STATIC', 'managed-host-static');

/**
 * Server type for servers that want to have their host files managed by
 * the toolkit.
 * 
 * @ingroup server_types
 */
define('SERVER_TYPE_MANAGED_HOST', 'managed-host');

/**
 * Set to TRUE to prevent the local server from being used as a managed host
 * server.
 * 
 * @ingroup config
 */
define('CONFIG_DISABLE_LOCAL_MANAGED_HOST', 'si-disable-local-managed-host');

/**
 * Fired when a managed host needs to be cast into a HostFileManagerInterface
 * object.
 * 
 * @ingroup events
 */
define('EVENT_CAST_MANAGED_HOST_SERVER', 'cast-managed-host-server');

/**
 * Fired when a list of managed hosts is needed.
 * 
 * @ingroup events
 */
define('EVENT_FIND_MANAGED_HOST_SERVERS', 'find-managed-host-servers');

/**
 * Allows changing the managed host type.
 * 
 * @ingroup server_settings
 * @see @ref managed_host_types "Managed Host Types"
 */
define('SERVER_SETTING_ENVIRONMENT', 'managed-host-type');

/**
 * Server setting to prevent the hosts file from being updated during the 
 * update process.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_STATIC_HOSTS', 'managed-host-static');

/**
 * Config key to compact the hosts files.
 * 
 * If set to TRUE, all hosts files will be compacted preserving comments. See
 * hosts_file_compact() for the impact of this.
 * 
 * @ingroup config
 */
define('CONFIG_MANAGED_HOSTS_COMPACT', 'compact-hosts-file');

/**
 * Indicates that the host is a Linux machine.
 * 
 * @ingroup managed_host_types
 */
define('MANAGED_HOST_TYPE_LINUX', 'linux');

/**
 * String token for when there was an error writing out the hosts file.
 * 
 * @ingroup strings
 */
define('STRING_HOSTS_FILE_BAD_WRITE', 'hosts_config.error.bad_write');

/**
 * Site setting for the list of machines where we need to remove this site
 * from the hosts file.
 * 
 * @ingroup site_settings
 */
define('SITE_HOST_FILES', 'host-files');

/**
 * String token for the message when there was an error cleaning up the hosts 
 * file.
 * 
 * @ingroup strings
 */
define('STRING_HOST_REMOVAL_ERROR', 'hosts_config.error.unable-to-clean-host-file');

/**
 * Plugin to manage the hosts file configuration of one or more servers.
 */
class HostsConfigurationPlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $base = dirname(__FILE__);
    require assemble_path($base, 'HostFileManagerInterface.iface');
    require assemble_path($base, 'GenericHostFileManager.class');
    require assemble_path($base, 'LinuxHostFileManager.class');
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_MANAGED_HOSTS_COMPACT => FALSE,
      CONFIG_MANAGED_HOSTS_USE_LOCAL => TRUE,
      CONFIG_MANAGED_HOSTS_DEFAULT_TYPE => MANAGED_HOST_TYPE_LINUX,
      CONFIG_MANAGED_HOSTS_TARGET_IP_ADDRESS => '127.0.0.1',
      CONFIG_SERVER_LIST => array(
        SERVER_TYPE_MANAGED_HOST => array(),
      ),
    ));
    $this->events()->registerListener(array(
      EVENT_UPDATE_REFRESH_SERVER_CONFIG,
      EVENT_CAST_MANAGED_HOST_SERVER,
      EVENT_SITE_BUILD_MORE_CONFIG,
      EVENT_FIND_MANAGED_HOST_SERVERS,
      EVENT_REMOVE_ALL,
      EVENT_SUBSITE_BUILD_PARENT_SERVER_REFRESH,
    ), $this);
  }
  
  public function requiredPlugins() {
    return array('ServerInteractionPlugin', 'DrupalSitePlugin');
  }
  
  public function captureEvent(&$context, $eventType) {
    switch ($eventType) {
      case EVENT_SUBSITE_BUILD_PARENT_SERVER_REFRESH:
        if (empty($context->handled) || $context->success) {
          $context->success = $this->updateHostFile($context->subsite->getParentSite());
          $context->handled = TRUE;
        }
        break;
      case EVENT_UPDATE_REFRESH_SERVER_CONFIG:
        if ((!$context->handled) || $context->success) {
          $context->success = $this->refreshHostFiles($context->site);
          $context->handled = TRUE;
        }
        break;
      case EVENT_FIND_MANAGED_HOST_SERVERS:
        $context->servers = array_merge($context->servers, $this->findManagedHostServers());
        break;
      case EVENT_CAST_MANAGED_HOST_SERVER:
        $casted = $this->castManagedHostServer($context->server, $context->type);
        if (!empty($casted)) {
          $context->stopPropagation = TRUE;
          $context->managedHostServer = $casted;
        }
        break;
      case EVENT_SITE_BUILD_MORE_CONFIG:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->updateHostFile($context->site);
        }
        break;
      case EVENT_REMOVE_ALL:
        $context->success = $this->cleanHostFiles($context->site) && $context->success;
        break;
    }
  }
  
  /**
   * Refreshes the hosts file configuration.
   * 
   * @param DrupalSite $site
   *   Site to refresh.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function refreshHostFiles(DrupalSite $site) {
    if (extra_empty($this->config()->getConfig(CONFIG_MANAGED_HOSTS_STATIC))) {
      return $this->updateHostFile($site, TRUE);
    }
    else {
      return TRUE;
    }
  }
  
  /**
   * Cleans up the host files.
   * 
   * @param DrupalSite $site
   *   The DrupalSite to cleanup host files for.
   * 
   * @return boolean
   *   TRUE if all the files were cleaned up, otherwise FALSE.
   */
  private function cleanHostFiles(DrupalSite $site) {
    $hosts = $site->getSetting(SITE_HOST_FILES);
    $r = TRUE;
    foreach ($hosts['servers'] as $host) {
      if ($host instanceof HostFileManagerInterface) {
        if (!$host->cleanHostEntries($hosts['map'])) {
          $this->warn(STRING_HOST_REMOVAL_ERROR);
          $r = FALSE;
        }
      }
      else {
        $this->warn(STRING_HOST_REMOVAL_ERROR);
        $r = FALSE;
      }
    }
    return $r;
  }
  
  /**
   * Responsible for updating the hosts file of many servers.
   * 
   * @param DrupalSite $site
   *   The site we're creating host file entries for.
   * @param boolean $update
   *   Whether or not this is an update process.
   * 
   * @return boolean
   *   TRUE if all the hosts files were updated successfully, otherwise FALSE.
   */
  private function updateHostFile(DrupalSite $site, $update = FALSE) {
    $config = $this->getConfig(array(
      'ip' => CONFIG_MANAGED_HOSTS_TARGET_IP_ADDRESS,
    ));
    if (empty($config)) {
      return FALSE;
    }
    $map = array();
    foreach ($site->getSetting(SITE_SETTING_ALL_DOMAINS) as $host) {
      $map[$host] = $config['ip'];
    }
    $context = (object) array(
      'servers' => array(),
    );
    $this->events()->fireEvent(EVENT_FIND_MANAGED_HOST_SERVERS, $context);
    $registry = array(
      'servers' => array(),
      'map' => $map,
    );
    foreach ($context->servers as $server) {
      if ($server instanceof HostFileManagerInterface) {
        if ($update) {
          if (!extra_empty($server->machine()->getSetting(SERVER_SETTING_STATIC_HOSTS))) {
            continue;
          }
        }
        if (!$server->addHostFileEntries($map)) {
          $this->error(STRING_HOSTS_FILE_BAD_WRITE);
          return FALSE;
        }
        $registry['servers'][] = $server;
      }
    }
    $site->setSetting(SITE_HOST_FILES, $registry);
    return TRUE;
  }
  
  /**
   * Retrieves managed host servers from the ServerInteractionPlugin.
   * 
   * @return array
   *   An array of managed host servers.
   */
  private function findManagedHostServers() {
    $defaultType = $this->config()->getConfig(CONFIG_MANAGED_HOSTS_DEFAULT_TYPE);
    $context = (object) array(
      'serverType' => SERVER_TYPE_MANAGED_HOST,
      'skipLocal' => FALSE,
      'servers' => array(),
    );
    if (extra_empty($this->config()->getConfig(CONFIG_MANAGED_HOSTS_USE_LOCAL))) {
      $context->use_local = FALSE;
    }
    $this->events()->fireEvent(EVENT_FIND_SERVERS, $context);    
    $servers = array();
    foreach ($context->servers as $server) {
      if ($server instanceof PhysicalServerInterface) {
        $type = $server->getSetting(SERVER_SETTING_ENVIRONMENT);
        if (empty($type)) {
          $type = $defaultType;
        }
        $managedHostServer = $this->getCastedServer($server, $type);
        if (!empty($managedHostServer)) {
          $servers[] = $managedHostServer;
        }
      }
    }
    return $servers;
  }
  
  /**
   * Retrieves the casted server by firing an event to find the type.
   * 
   * @param PhysicalServerInterface $server
   *   The server we're casting.
   * @param string $type
   *   The type we're casting to.
   * 
   * @return HostFileManagerInterface
   *   An appropriately casted object or NULL if none could be found.
   */
  private function getCastedServer(PhysicalServerInterface $server, $type) {
    $context = (object) array(
      'server' => $server,
      'type' => $type,
      'managedHostServer' => NULL,
    );
    $compacted = FALSE;
    if (!extra_empty($this->config()->getConfig(CONFIG_MANAGED_HOSTS_COMPACT))) {
      $compacted = TRUE;
    }
    $this->events()->fireEvent(EVENT_CAST_MANAGED_HOST_SERVER, $context);
    if (!empty($context->managedHostServer) && ($context->managedHostServer instanceof HostFileManagerInterface)) {
      $context->managedHostServer->setCompactHostFile($compacted);
    }
    return $context->managedHostServer;
  }
  
  private function castManagedHostServer(PhysicalServerInterface $server, $type) {
    switch ($type) {
      case MANAGED_HOST_TYPE_LINUX:
        return new LinuxHostFileManager($server);
        break;
    }
    return NULL;
  }
  
}