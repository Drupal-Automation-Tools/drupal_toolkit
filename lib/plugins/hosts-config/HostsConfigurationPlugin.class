<?php
/**
 * @file Defines the HostsConfigurationPlugin class.
 * 
 * @defgroup managed_host_types "Managed Host Server Types"
 * The different types of managed hosts that can be set. 
 */

/**
 * Plugin to manage the hosts file configuration of one or more servers.
 * 
 * @ingroup plugins
 */
class HostsConfigurationPlugin extends GenericPlugin implements EventListener, ServerInteractionDependency {

  /**
   * Dependency injection variable for the server interaction manager.
   * 
   * @var ServerInteractionManagerInterface
   */
  private $servers;
  
  public function setServerManager(ServerInteractionManagerInterface $servers) {
    $this->servers = $servers;
  }
  
  public function servers() {
    return $this->servers;
  }
  
  public function initialize() {
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_MANAGED_HOSTS_COMPACT => FALSE,
      CONFIG_MANAGED_HOSTS_USE_LOCAL => TRUE,
      CONFIG_MANAGED_HOSTS_DEFAULT_TYPE => MANAGED_HOST_TYPE_LINUX,
      CONFIG_MANAGED_HOSTS_TARGET_IP_ADDRESS => '127.0.0.1',
      CONFIG_SERVER_LIST => array(
        SERVER_TYPE_MANAGED_HOST => array(),
      ),
    ));
    $this->events()->registerListener(array(
      EVENT_UPDATE_REFRESH_SERVER_CONFIG,
      EVENT_CAST_MANAGED_HOST_SERVER,
      EVENT_SITE_BUILD_MORE_CONFIG,
      EVENT_FIND_MANAGED_HOST_SERVERS,
      EVENT_REMOVE_ALL,
      EVENT_SUBSITE_BUILD_PARENT_SERVER_REFRESH,
      EVENT_REMOVE_SUBSITE_CLEANUP,
    ), $this);
  }
  
  public function captureEvent(DtkEvent &$context, $eventType) {
    switch ($eventType) {
      case EVENT_REMOVE_SUBSITE_CLEANUP:
      case EVENT_REMOVE_ALL:
      case EVENT_SITE_BUILD_MORE_CONFIG:
      case EVENT_SUBSITE_BUILD_PARENT_SERVER_REFRESH:
        if ($context->checkExecution()) {
          $context->setResult($this->updateHostFile($context->getSite()));
        }
        break;
      case EVENT_UPDATE_REFRESH_SERVER_CONFIG:
        if ($context->checkExecution()) {
          $context->setResult($this->refreshHostFiles($context->getSite()));
        }
        break;
      case EVENT_CAST_MANAGED_HOST_SERVER:
        if ($context->checkExecution()) {
          $context->setCastedServer($this->castManagedHostServer($context->getServer(), $context->getType()));
        }
        break;
    }
  }
  
  /**
   * Refreshes the hosts file configuration.
   * 
   * @param DrupalSite $site
   *   Site to refresh.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function refreshHostFiles(DrupalSite $site) {
    if (extra_empty($this->config()->getConfig(CONFIG_MANAGED_HOSTS_STATIC))) {
      return $this->updateHostFile($site, TRUE);
    }
    else {
      return TRUE;
    }
  }
  
  /**
   * Retrieves a list of servers that need a host file update.
   * 
   * @return array
   *   An array of HostFileManagerInterface objects.
   */
  private function getHostServers() {
    return $this->servers()->getServerList(
        SERVER_TYPE_MANAGED_HOST,
        EVENT_CAST_MANAGED_HOST_SERVER,
        SERVER_SETTING_ENVIRONMENT,
        $this->config()->getConfig(CONFIG_MANAGED_HOSTS_DEFAULT_TYPE),
        !extra_empty($this->config()->getConfig(CONFIG_MANAGED_HOSTS_USE_LOCAL))
    );
  }
  
  /**
   * Assembles the configuration that needs to be used to update
   * all the host files.
   * 
   * @param DrupalSite $site
   *   The Drupal site to get data for.
   * 
   * @return array
   *   An associative array of data for updateHostFileConfiguration() or
   *   FALSE if some variables could not be determined.
   */
  private function getHostConfiguration(DrupalSite $site) {
    $c = $this->getConfig(array(
      'ip' => CONFIG_MANAGED_HOSTS_TARGET_IP_ADDRESS,
    ));
    if (empty($c)) { return FALSE; }
    $config = array(
      'ip' => $c['ip'],
    );
    $config['map'] = array();
    foreach ($site->getRecursiveDomains() as $host) {
      $config['map'][$host] = $c['ip'];
    }
    $config['loaded'] = $site->getSetting(SITE_HOST_FILES, array());
    $config['registry'] = array(
      'map' => $config['map'],
      'originals' => array(),
    );
    $config['missing'] = array();
    if (!empty($config['loaded']['map'])) {
      foreach (array_keys($config['loaded']['map']) as $host) {
        if (!isset($config['map'][$host])) {
          $config['missing'][$host] = $c['ip'];
        }
      }
    }
    return $config;
  }
  
  /**
   * Updates the host file for a particular server.
   * 
   * @param HostFileManagerInterface $server
   *   The server to update.
   * @param string $key
   *   The identifier for the server.
   * @param array $config
   *   Configuration as generated by getHostConfiguration().
   */
  private function updateHostFileConfiguration(HostFileManagerInterface $server, $key, &$config, $overrideIP = NULL) {
    $config['registry']['originals'][$key] = array();
    foreach ($config['map'] as $host => $ip) {
      if (!empty($overrideIP)) { $ip = $overrideIP; }
      if (isset($config['loaded']['originals'][$key][$host])) {
        $config['registry']['originals'][$key][$host] = $config['loaded']['originals'][$key][$host];
      }
      else {
        $original = $server->getHostFileEntry($host);
        if (!empty($original) && ($original !== $ip)) {
          $config['registry']['originals'][$key][$host] = $original;
        }
      }
      $server->addHostFileEntry($host, $ip);
    }
    $server->cleanHostEntries($config['missing']);
    foreach (array_keys($config['missing']) as $host) {
      if (isset($config['loaded']['originals'][$key][$host])) {
        $server->addHostFileEntry($host, $config['loaded']['originals'][$key][$host]);
      }
    }
  }
  
  /**
   * Responsible for updating the hosts file of many servers.
   * 
   * @param DrupalSite $site
   *   The site we're creating host file entries for.
   * @param boolean $update
   *   Whether or not this is an update process.
   * 
   * @return boolean
   *   TRUE if all the hosts files were updated successfully, otherwise FALSE.
   */
  private function updateHostFile(DrupalSite $site, $update = FALSE) {
    $this->working(STRING_WORKING_UPDATING_HOSTS);
    $config = $this->getHostConfiguration($site);
    if (empty($config)) { return FALSE; }
    $servers = $this->getHostServers();
    foreach ($servers as $key => $server) {
      if ($server instanceof HostFileManagerInterface) {
        if ($update) {
          if (!extra_empty($server->machine()->getSetting(SERVER_SETTING_STATIC_HOSTS))) {
            continue;
          }
        }
        $override = $server->machine()->getSetting(SERVER_SETTING_HOST_IP_OVERRIDE, NULL);
        $this->working(STRING_WORKING_UPDATING_HOSTS_ITEM, array(
          '!name' => $key,
        ));
        $this->updateHostFileConfiguration($server, $key, $config, $override);
        if (!$server->saveHostFile()) {
          $this->error(STRING_HOSTS_FILE_BAD_WRITE);
          return FALSE;
        }
      }
    }
    $site->setSetting(SITE_HOST_FILES, $config['registry']);
    $this->success(STRING_SUCCESS_UPDATING_HOSTS);
    return TRUE;
  }
  
  /**
   * Casts a physical server interface into an instance of HostFileManagerInterface
   * if there is an appropriate interface for $type found.
   * 
   * @param PhysicalServerInterface $server
   *   The server to cast.
   * @param string $type
   *   A supported type.
   * 
   * @return HostFileManagerInterface
   *   An instance of HostFileManagerInterface or NULL if no matching type was
   *   found.
   */
  private function castManagedHostServer(PhysicalServerInterface $server, $type) {
    switch ($type) {
      case MANAGED_HOST_TYPE_LINUX:
        return new LinuxHostFileManager($server);
        break;
    }
    return NULL;
  }
  
}