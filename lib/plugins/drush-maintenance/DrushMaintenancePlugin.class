<?php
/**
 * @file Defines the DrushMaintenancePlugin class.
 */

/**
 * String token for when maintenance mode fails to engage.
 * 
 * @ingroup string
 */
define('STRING_MAINTENANCE_MODE_FAILURE', 'drush_maintenance.error.maintenance-mode-failure');

/**
 * String token for when maintenance mode is about to be engaged.
 * 
 * @ingroup string
 */
define('STRING_WORKING_MAINTENANCE_MODE_ENGAGE', 'drush_maintenance.working.engage');

/**
 * String token for when maintenance mode is about to be disengaged.
 * 
 * @ingroup string
 */
define('STRING_WORKING_MAINTENANCE_MODE_DISENGAGE', 'drush_maintenance.working.disengage');

/**
 * String token for when maintenance mode is about to be engaged.
 * 
 * @ingroup string
 */
define('STRING_WORKING_MAINTENANCE_MODE_ENGAGE_ITEM', 'drush_maintenance.working.engage-item');

/**
 * String token for when maintenance mode is about to be disengaged.
 * 
 * @ingroup string
 */
define('STRING_WORKING_MAINTENANCE_MODE_DISENGAGE_ITEM', 'drush_maintenance.working.disengage-item');

/**
 * String token for when maintenance mode has been engaged.
 * 
 * @ingroup string
 */
define('STRING_SUCCESS_MAINTENANCE_MODE_ENGAGE', 'drush_maintenance.success.engage');

/**
 * String token for when maintenance mode has been disengaged.
 * 
 * @ingroup string
 */
define('STRING_SUCCESS_MAINTENANCE_MODE_DISENGAGE', 'drush_maintenance.success.disengage');

/**
 * Responsible for various functions relating to the update process.
 */
class DrushMaintenancePlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $this->events()->registerListener(array(
      EVENT_UPDATE_PREPARE_FOR_UPDATE,
      EVENT_UPDATE_PREPARE_FOR_REFRESH,
      EVENT_ROLLBACK_FINISH,
      EVENT_ROLLBACK_PREPARE,
    ), $this);
  }
  
  public function captureEvent(&$context, $eventType) {
    switch ($eventType) {
      case EVENT_ROLLBACK_FINISH:
      case EVENT_UPDATE_PREPARE_FOR_REFRESH:
        if (empty($context->handled) || $context->success) {
          $context->success = $this->setMaintenanceMode($context->site, FALSE);
          $context->handled = TRUE;
        }
        break;
      case EVENT_ROLLBACK_PREPARE:
      case EVENT_UPDATE_PREPARE_FOR_UPDATE:
        if (empty($context->handled) || $context->success) {
          $context->success = $this->setMaintenanceMode($context->site, TRUE);
          $context->handled = TRUE;
        }
        break;
    }
  }
  
  /**
   * Manages the maintenance mode for a site.
   * 
   * @param DrupalSite $site
   *   The DrupalSite to change the maintenance mode on.
   * @param boolean $on
   *   TRUE to engage maintenance mode, FALSE to disengage it.
   * 
   * @return boolean
   *   TRUE if the maintenance mode was correctly set on all aliases, otherwise
   *   FALSE.
   */
  private function setMaintenanceMode(DrupalSite $site, $on = TRUE) {
    $aliases = $site->getSetting(SITE_DRUSH_ALIASES);
    if ($on) {
      $this->working(STRING_WORKING_MAINTENANCE_MODE_ENGAGE);
    }
    else {
      $this->working(STRING_WORKING_MAINTENANCE_MODE_DISENGAGE);
    }
    foreach ($aliases as $alias) {
      if ($on) {
        $this->working(STRING_WORKING_MAINTENANCE_MODE_ENGAGE_ITEM, array(
          '!alias' => $alias,
        ));
      }
      else {
        $this->working(STRING_WORKING_MAINTENANCE_MODE_DISENGAGE_ITEM, array(
          '!alias' => $alias,
        ));
      }
      if (!drush_maintenance_mode(!!$on, $alias)) {
        $this->error(STRING_MAINTENANCE_MODE_FAILURE, array(
          '!state' => $on ? 1 : 0,
          '!alias' => $alias,
        ));
        return FALSE;
      }
    }
    if ($on) {
      $this->working(STRING_SUCCESS_MAINTENANCE_MODE_ENGAGE);
    }
    else {
      $this->working(STRING_SUCCESS_MAINTENANCE_MODE_DISENGAGE);
    }
    return TRUE;
  }
  
}