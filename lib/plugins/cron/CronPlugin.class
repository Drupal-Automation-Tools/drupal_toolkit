<?php
/**
 * @file Defines the CronPlugin class.
 * 
 * @defgroup cron_types "Cron Types"
 * The different type of cron jobs that can be installed.
 */

/**
 * Configure the setting that will be passed to crontab implementations.
 * 
 * This should be five values separated by spaces in the following order:
 * - minute (0-59)
 * - hour (0-23)
 * - day of the month (1-31)
 * - month (1-12
 * - day of the week (0-6, 0 is Sunday)
 * 
 * Special characters may depend on the exact Linux version in use:
 * - Spaces separate all five fields
 * - Commas separate multiple values within fields
 * - Hyphens separate ranges within fields
 * - Asterisk is a wildcard indicating all values
 * - Slashes indicate an interval of values
 * - At sign (@) or capital H indicates a random value between the min and 
 *   max value inclusive. Note that using an interval on a random value will
 *   limit the random value to min-(interval-1). If this is not desired, the
 *   random range can be explicitly declared as below.
 * - Random values can have limits, either @(max) or @(min, max). If min is 
 *   omitted, it defaults to the smallest value for the field.
 * 
 * Some special names can also be used instead of the five fields:
 * - @yearly and @annually indicates yearly execution on Jan 1
 * - @monthly indicates monthly execution on the first day of the month
 * - @weekly indicates executing every week on Sunday morning
 * - @daily indicates executing every day at midnight
 * - @hourly indicates executing every hour at the hour
 * 
 * @ingroup config
 */
define('CONFIG_CRONTAB_FREQUENCY', 'crontab-frequency');

/**
 * String for when a cron URL could not be determined.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_NO_CRON_URL', 'cron_plugin.error.no-url');

/**
 * String for when a cron job could not be installed.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_COULD_NOT_CREATE_CRON', 'cron_plugin.error.bad-creation');

/**
 * The set of servers that all need a cron job installed on them.
 * 
 * @ingroup server_types
 */
define('SERVER_TYPE_CRON', 'cron');

/**
 * Fired to cast a cron server to an instance of CronManagerInterface.
 * 
 * @ingroup events
 */
define('EVENT_CAST_CRON_SERVER', 'cast-cron-server');

/**
 * Server setting to override the cron type.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_CRON_TYPE', 'cron-type');

/**
 * Fallback value for SERVER_SETTING_CRON_TYPE. Also impacts the localhost
 * configuration.
 * 
 * @ingroup config
 */
define('CONFIG_DEFAULT_CRON_TYPE', 'cron-type-default');

/**
 * Cron type for a Linux crontab implementation that allows config files to be
 * dropped into /etc/cron.d
 * 
 * @ingroup cron_types
 */
define('CRON_TYPE_CRONTAB', 'crontab');

/**
 * Stores the list of cron machines.
 * 
 * @ingroup site_settings
 */
define('SITE_CRON_MACHINES', 'cron-machines');

/**
 * String for if a cron task could not be deleted.
 * 
 * @ingroup strings
 */
define('STRING_COULD_NOT_DELETE_CRON', 'cron_plugin.error.could-not-delete-task');

/**
 * String for if a server could not be initialized.
 * 
 * @ingroup strings
 */
define('STRING_COULD_NOT_INIT_SERVER', 'cron_plugin.error.could-not-init-server');

/**
 * Config setting to prevent cron tasks from being updated.
 * 
 * @ingroup config
 */
define('CONFIG_STATIC_CRON', 'cron-static-config');

/**
 * Server setting to prevent the cron task from being updated.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_STATIC_CRON', 'cron-static-config');

/**
 * String for telling the user that the cron tasks are being deleted.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_CRON_DELETE', 'cron.working.delete');

/**
 * String for telling the user that the cron tasks were deleted.
 * 
 * @ingroup strings
 */
define('STRING_SUCCESS_CRON_DELETE', 'cron.success.delete');

/**
 * String for telling the user that cron tasks are being setup.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_CRON_SETUP', 'cron.working.setup');

/**
 * String for telling the user that cron tasks were setup properly.
 * 
 * @ingroup strings
 */
define('STRING_SUCCESS_CRON_SETUP', 'cron.success.setup');
  
/**
 * String for telling the user that a cron task item is being deleted.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_CRON_DELETE_ITEM', 'cron.working.delete_item');

/**
 * String for telling the user that a cron task item is being setup.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_CRON_SETUP_ITEM', 'cron.working.setup_item');

/**
 * Responsible for installing cron tasks for Drupal.
 */
class CronPlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $base = dirname(__FILE__);
    require assemble_path($base, 'CronManagerInterface.iface');
    require assemble_path($base, 'GenericCronManager.class');
    require assemble_path($base, 'LinuxCrontab.class');
    $this->events()->registerListener(array(
      EVENT_INSTALL_EXTRAS,
      EVENT_CAST_CRON_SERVER,
      EVENT_REMOVE_ALL,
      EVENT_UPDATE_PRIOR_ACTIONS,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_CRONTAB_FREQUENCY => '@daily',
      CONFIG_DEFAULT_CRON_TYPE => CRON_TYPE_CRONTAB,
      CONFIG_STATIC_CRON => FALSE,
    ));
    $this->error('NOTHING', array(), CLOG_CRITICAL);
  }
  
  public function captureEvent(&$context, $eventType) {
      case EVENT_UPDATE_PRIOR_ACTIONS:
        if (empty($context->handled) || $context->success) {
          $context->success = $this->updateAll($context->site);
          $context->handled = TRUE;
        }
        break;
      case EVENT_REMOVE_SUBSITE_ALL:
      case EVENT_REMOVE_ALL:
        $context->success = $this->deleteCronTasks($context->site) && $context->success;
        $context->handled = TRUE;
        break;
      case EVENT_INSTALL_EXTRAS:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->installCronJob($context->site);
        }
        break;
      case EVENT_CAST_CRON_SERVER:
        if (empty($context->cronServer)) {
          $context->cronServer = $this->castCronMachine($context->server, $context->cronType);
        }
    }
  }
  
  public function requiredPlugins() {
    return array('DrupalSitePlugin', 'DrushConfigurationPlugin');
  }
  
  /**
   * Updates all the cron tasks associated with a site.
   * 
   * @param DrupalSite $site
   *   The site to update cron tasks.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function updateAll(DrupalSite $site) {
    if (extra_empty($this->config()->getConfig(CONFIG_STATIC_CRON))) {
      return $this->installCronJob($site, TRUE);
    }
    return TRUE;
  }
  
  /**
   * Deletes all the cron tasks from a site.
   * 
   * @param GenericDrupalEntity $site
   *   The site to delete cron tasks.
   * 
   * @return boolean
   *   TRUE if success, otherwise FALSE.
   */
  private function deleteCronTasks(GenericDrupalEntity $site) {
    $alias = $site->getSetting(SITE_DRUSH_ALIAS);
    if (empty($alias)) {
      $this->error(STRING_SITE_MISSING_SETTING, array(
        '!key' => SITE_DRUSH_ALIAS
      ));
      return FALSE;
    }
    $ret = TRUE;
    $machines = $site->getSetting(SITE_CRON_MACHINES);
    if (empty($machines)) {
      return TRUE;
    }
    $this->working(STRING_WORKING_CRON_DELETE);
    foreach ($machines as $key => $machine) {
      $this->working(STRING_WORKING_CRON_DELETE_ITEM, array(
        '!name' => $key,
      ));
      $valid = FALSE;
      if ($machine instanceof CronManagerInterface) {
        if ($machine->machine()->initialize()) {
          $valid = TRUE;
          if (!$machine->deleteScheduledTask($alias)) {
            $this->warn(STRING_COULD_NOT_DELETE_CRON, array(
              '!site' => $key,
              '!alias' => $alias,
            ));
            $ret = FALSE;
          }
        }
      }
      if (!$valid) {
        $this->warn(STRING_COULD_NOT_INIT_SERVER, array(
          '!site' => $key,
        ));
        $ret = FALSE;
      }
    }
    if ($ret) {
      $this->success(STRING_SUCCESS_CRON_DELETE);
    }
    return $ret;
  }
  
  /**
   * Casts a server for cron usage.
   * 
   * @param PhysicalServerInterface $server
   *   The server being cast.
   * 
   * @param string $type
   *   The type string to cast the server based on.
   * 
   * @return CronManagerInterface
   *   A cron manager object, or NULL if $type is not appropriate.
   */
  private function castCronMachine(PhysicalServerInterface $server, $type) {
    switch ($type) {
      case CRON_TYPE_CRONTAB:
        return new LinuxCrontab($server);
    }
    return NULL;
  }
  
  /**
   * Fetches a list of machines to use for cron.
   * 
   * @return array
   *   An array of CronManagerInterface objects
   */
  private function getCronMachines() {
    $type = $this->config()->getConfig(CONFIG_DEFAULT_CRON_TYPE);
    $context = (object) array(
      'success' => FALSE,
      'handled' => FALSE,
      'servers' => array(),
      'skipLocal' => FALSE,
      'serverType' => SERVER_TYPE_CRON,
    );
    $this->events()->fireEvent(EVENT_FIND_SERVERS, $context);
    $machines = array();
    foreach ($context->servers as $k => $server) {
      if ($server instanceof PhysicalServerInterface) {
        $stype = $server->getSetting(SERVER_SETTING_CRON_TYPE);
        if (empty($stype)) {
          $stype = $type;
        }
        $next = (object) array(
          'success' => FALSE,
          'handled' => FALSE,
          'server' => $server,
          'cronServer' => NULL,
          'cronType' =>$stype,
        );
        $this->events()->fireEvent(EVENT_CAST_CRON_SERVER, $next);
        if (!empty($next->cronServer)) {
          $machines[$k] = $next->cronServer;
          $this->dm()->setDependencies($next->cronServer);
        }
      }
    }
    return $machines;
  }
  
  /**
   * Installs a cron job for the site.
   * 
   * @param DrupalSite $site
   *   The site to install cron tasks for.
   * 
   * @return boolean
   *   TRUE if the cron tabs were installed successfully, otherwise FALSE.
   */
  private function installCronJob(GenericDrupalEntity $site, $update = FALSE) {
    $alias = $site->getSetting(SITE_DRUSH_ALIAS);
    if (empty($alias)) {
      $this->error(STRING_SITE_MISSING_SETTING, array(
        '!key' => SITE_DRUSH_ALIAS
      ));
      return FALSE;
    }
    $cron = drush_get_cron_url($alias);
    if (empty($cron)) {
      $this->error(STRING_ERROR_NO_CRON_URL);
      return FALSE;
    }
    $this->working(STRING_WORKING_CRON_SETUP);
    $command = 'wget ' . escapeshellarg($cron);
    $machines = $this->getCronMachines();
    foreach ($machines as $key => $machine) {
      if ($machine instanceof CronManagerInterface) {
        if ($update) {
          if (!extra_empty($machine->machine()->getSetting(SERVER_SETTING_STATIC_CRON))) {
            continue;
          }
        }
        $this->working(STRING_WORKING_CRON_SETUP_ITEM, array(
          '!name' => $key,
        ));
        if (!$machine->scheduleTask($alias, $command)) {
          $this->error(STRING_ERROR_COULD_NOT_CREATE_CRON, array(
            '!server' => $key,
            '!alias' => $alias,
          ));
          return FALSE;
        }
      }
    }
    $this->success(STRING_SUCCESS_CRON_SETUP);
    $site->setSetting(SITE_CRON_MACHINES, $machines);
    return TRUE;
  }
  
}