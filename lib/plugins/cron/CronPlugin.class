<?php

/**
 * Configure the setting that will be passed to crontab implementations.
 * 
 * This should be five values separated by spaces in the following order:
 * - minute (0-59)
 * - hour (0-23)
 * - day of the month (1-31)
 * - month (1-12
 * - day of the week (0-6, 0 is Sunday)
 * 
 * Special characters may depend on the exact Linux version in use:
 * - Spaces separate all five fields
 * - Commas separate multiple values within fields
 * - Hyphens separate ranges within fields
 * - Asterisk is a wildcard indicating all values
 * - Slashes indicate an interval of values
 * - At sign (@) or capital H indicates a random value between the min and 
 *   max value inclusive. Note that using an interval on a random value will
 *   limit the random value to min-(interval-1). If this is not desired, the
 *   random range can be explicitly declared as below.
 * - Random values can have limits, either @(max) or @(min, max). If min is 
 *   omitted, it defaults to the smallest value for the field.
 * 
 * Some special names can also be used instead of the five fields:
 * - @yearly and @annually indicates yearly execution on Jan 1
 * - @monthly indicates monthly execution on the first day of the month
 * - @weekly indicates executing every week on Sunday morning
 * - @daily indicates executing every day at midnight
 * - @hourly indicates executing every hour at the hour
 * 
 * @ingroup config
 */
define('CONFIG_CRONTAB_FREQUENCY', 'crontab-frequency');

define('STRING_ERROR_NO_CRON_URL', 'cron_plugin.error.no-url');

define('STRING_ERROR_COULD_NOT_CREATE_CRON', 'cron_plugin.error.bad-creation');

define('SERVER_TYPE_CRON', 'cron');

define('EVENT_CAST_CRON_SERVER', 'cast-cron-server');

define('SERVER_SETTING_CRON_TYPE', 'cron-type');

define('CONFIG_DEFAULT_CRON_TYPE', 'cron-type-default');

define('CRON_TYPE_CRONTAB', 'crontab');

class CronPlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $this->events()->registerListen(array(
      EVENT_INSTALL_EXTRAS,
      EVENT_CAST_CRON_SERVER,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_CRONTAB_FREQUENCY => '@daily',
      CONFIG_DEFAULT_CRON_TYPE => CRON_TYPE_CRONTAB,
    ));
  }
  
  public function captureEvent(&$context, $eventType) {
    switch ($eventType) {
      case EVENT_INSTALL_EXTRAS:
        if (empty($context->handled) || $context->success) {
          $context->handled = TRUE;
          $context->success = $this->installCronJob($context->site);
        }
        break;
      case EVENT_CAST_CRON_SERVER:
        if (empty($context->cronServer)) {
          $context->cronServer = $this->castCronMachine($context->server, $context->cronType);
        }
    }
  }
  
  /**
   * Casts a server for cron usage.
   * 
   * @param PhysicalServerInterface $server
   *   The server being cast.
   * 
   * @param string $type
   *   The type string to cast the server based on.
   * 
   * @return CronManagerInterface
   *   A cron manager object, or NULL if $type is not appropriate.
   */
  private function castCronMachine(PhysicalServerInterface $server, $type) {
    switch ($type) {
      case CRON_TYPE_CRONTAB:
        return new LinuxCrontab($server);
    }
    return NULL;
  }
  
  /**
   * Fetches a list of machines to use for cron.
   * 
   * @return array
   *   An array of CronManagerInterface objects
   */
  private function getCronMachines() {
    $type = $this->config()->getConfig(CONFIG_DEFAULT_CRON_TYPE);
    $context = (object) array(
      'success' => FALSE,
      'handled' => FALSE,
      'servers' => array(),
      'skipLocal' => FALSE,
      'serverType' => SERVER_TYPE_CRON,
    );
    $this->events()->fireEvent(EVENT_FIND_SERVERS, $context);
    $machines = array();
    foreach ($context->servers as $k => $server) {
      if ($server instanceof PhysicalServerInterface) {
        $stype = $server->getSetting(SERVER_SETTING_CRON_TYPE);
        if (empty($stype)) {
          $stype = $type;
        }
        $next = (object) array(
          'success' => FALSE,
          'handled' => FALSE,
          'server' => $server,
          'cronServer' => NULL,
          'cronType' =>$stype,
        );
        $this->events()->fireEvent(EVENT_CAST_CRON_SERVER, $next);
        if (!empty($next->cronServer)) {
          $machines[$k] = $server;
        }
      }
    }
    return $machines;
  }
  
  /**
   * Installs a cron job for the site.
   * 
   * @param DrupalSite $site
   *   The site to install cron tasks for.
   * 
   * @return boolean
   *   TRUE if the cron tabs were installed successfully, otherwise FALSE.
   */
  private function installCronJob(DrupalSite $site) {
    $alias = $site->getSetting(SITE_DRUSH_ALIAS);
    if (empty($alias)) {
      $this->error(STRING_SITE_MISSING_SETTING, array(
        '!key' => SITE_DRUSH_ALIAS
      ));
      return FALSE;
    }
    $cron = drush_get_cron_url($alias);
    if (empty($cron)) {
      $this->error(STRING_ERROR_NO_CRON_URL);
      return FALSE;
    }
    $command = 'wget ' . escapeshellarg($cron);
    $machines = $this->getCronMachines();
    foreach ($machines as $key => $machine) {
      if ($machine instanceof CronManagerInterface) {
        if (!$machine->scheduleTask($alias, $command)) {
          $this->error(STRING_ERROR_COULD_NOT_CREATE_CRON, array(
            '!server' => $key,
            '!alias' => $alias,
          ));
          return FALSE;
        }
      }
    }
    return TRUE;
  }
  
}