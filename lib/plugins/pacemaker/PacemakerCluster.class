<?php
/**
 * @file Defines the PacemakerCluster class.
 * 
 * @defgroup pacemaker_modes "Pacemaker Modes"
 * These modes can be used with SERVER_SETTING_PACEMAKER_MODE in order to 
 * control which nodes are used by the cluster when executing commands. Usually
 * these modes only impact commands that might need to be executed on 
 * multiple machines like file pushes and restarting the web server.
 */

/**
 * If set to TRUE, any reference to the system currently executing the command
 * will be ignored.
 * 
 * This will be determined by comparing the key of the server within
 * SERVER_SETTING_PACEMAKER_CLUSTER against the current system's hostname.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_PACEMAKER_IGNORE_LOCAL', 'pacemaker-ignore-local');

/**
 * Setting that defines the set of servers, in the order they should be checked
 * for which one is the active server.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_PACEMAKER_CLUSTER', 'pacemaker-cluster');

/**
 * Controls which servers will be used for commands issued to the cluster. Uses
 * the @ref pacemaker_modes "pacemaker modes".
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_PACEMAKER_COMMAND_MODE', 'pacemaker-command-mode');

/**
 * Controls which servers will be used for file writes issued to the cluster.
 * Uses the @ref pacemaker_modes "pacemaker modes".
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_PACEMAKER_WRITE_MODE', 'pacemaker-write-mode');

/**
 * This @ref pacemaker_modes "pacemaker mode" indicates to only talk to the
 * current decision controller server in issuing commands.
 * 
 * @ingroup pacemaker_modes
 */
define('PACEMAKER_MODE_DC_ONLY', 'dc');

/**
 * This @ref pacemaker_modes "pacemaker mode" indicates to only talk to 
 * defined servers in SERVER_SETTING_PACEMAKER_CLUSTER that are also online.
 * 
 * @ingroup pacemaker_modes
 */
define('PACEMAKER_MODE_ONLINE_ONLY', 'online');

/**
 * This @ref pacemaker_modes "pacemaker mode" indicates to talk to all defined
 * servers in SERVER_SETTING_PACEMAKER_CLUSTER. If one is not online, it is
 * considered an error.
 * 
 * @ingroup pacemaker_modes
 */
define('PACEMAKER_MODE_ALL', 'all');

/**
 * Represents a cluster of pacemaker servers, providing a method for accessing
 * them.
 * 
 * Only machines that are selected using one of the 
 * SERVER_SETTING_PACEMAKER_USE_* constants will be used in executing commands.
 * 
 * Delegation is used to allow some or all machines to participate in each 
 * command, as follows: 
 * - Commands executed via executeCommand() are each executed on all machines
 *   as defined by the SERVER_SETTING_PACEMAKER_COMMAND_MODE setting.
 * - Files are uploaded and deleted on all machines as defined by the
 *   SERVER_SETTING_PACEMAKER_WRITE_MODE setting. Note that if a file share is
 *   in use on the server, it may be useful to limit this to the DC only.
 * - Files are downloaded from the decision node only. File lists and 
 *   directory lists are also generated by the decision node only.
 * - Other commands usually rely on one of the above commands and are therefore
 *   delegated appropriately.
 * 
 * Some guidelines:
 * - DC_ONLY should be used where only the active server needs to have the 
 *   file written to it (because it is written to a share) or where the command
 *   must only be executed on a single node.
 * - ONLINE_ONLY should be used where all online servers can run the command
 *   or write the file without harm. If the file is essential in the case of 
 *   a fail-over, then ALL should be used instead.
 * - ALL should be used when it essential that all servers have the information
 *   written to them or the command executed. Should be used if error conditions
 *   might occur if a server is missed.
 */
class PacemakerCluster extends RemoteMachine {

  private $allMachines = array();
  private $commandMachines = array();
  private $fileMachines = array();
  private $dcMachine = FALSE;
  
  private $dcNode = NULL;
  private $onlineNodes = array();
    
  public function initialize() {
    $this->initMachineList();
    if (!$this->initClusterInfo()) {
      return FALSE;
    }
    $this->commandMachines = $this->getClusterMachines($this->getSetting(SERVER_SETTING_PACEMAKER_COMMAND_MODE));
    $this->fileMachines = $this->getClusterMachines($this->getSetting(SERVER_SETTING_PACEMAKER_WRITE_MODE));
    if (isset($this->allMachine[$this->dcNode])) {
      $this->dcMachine = $this->allMachine[$this->dcNode];
    }
    if ($this->commandMachines === FALSE || $this->fileMachines === FALSE || $this->dcMachine === FALSE) {
      return FALSE;
    }
    return TRUE;
  }
  
  public function sleep() {
    foreach ($this->allMachines as $machine) {
      if (!empty($machine)) {
        $machine->sleep();
      }
    }
  }
  
  public function executeCommand($command, $args, &$out = array(), &$exit = 0) {
    $last = NULL;
    foreach ($this->getCommandMachines() as $machine) {
      $out = array();
      $exit = 1;
      $last = $machine->executeCommand($command, $args, $out, $exit);
    }
    return $last;
  }
  
  public function writeFile($destination, $contents, $mode = 0644) {
    $success = TRUE;
    foreach ($this->getFileMachines() as $machine) {
      $success = $machine->writeFile($destination, $contents, $mode) && $success;
    }
    return $success;
  }
  
  public function downloadFile($file, $destination = NULL) {
    return $this->getDecisionNode()->downloadFile($file, $destination);
  }
  
  public function deleteFile($file) {
    $success = TRUE;
    foreach ($this->getFileMachines() as $machine) {
      $success = $machine->deleteFile($file) && $success;
    }
    return $success;
  }
  
  public function listFiles($dir) {
    return $this->getDecisionNode()->listFiles($dir);
  }
  
  public function listDirectories($dir) {
    return $this->getDecisionNode()->listDirectories($dir);
  }
  
  /**
   * Retrieves the current decision controller node.
   * 
   * @return PhysicalServerInterface
   *   The decision controller machine.
   */
  protected function getDecisionNode() {
    return $this->dcMachine;
  }
  
  /**
   * Retrieves an array of machines that commands should be executed on.
   * 
   * @return array
   *   An array of PhysicalServerInterface objects.
   */
  protected function getCommandMachines() {
    return $this->commandMachines;
  }
  
  /**
   * Retrieves an array of machines that files should be uploaded to.
   * 
   * @return array
   *   An array of PhysicalServerInterface objects.
   */
  protected function getFileMachines() {
    return $this->fileMachines;
  }
  
  /**
   * Initializes all the machines that are accessible.
   */
  private function initMachineList() {
    $machines = $this->getSetting(SERVER_SETTING_PACEMAKER_CLUSTER);
    $host = get_hostname();
    $useLocal = extra_empty($this->getSetting(SERVER_SETTING_PACEMAKER_IGNORE_LOCAL));
    foreach ($machines as $key => $machine) {
      $psi = NULL;
      if ($key === $host) {
        if (!$useLocal) {
          continue;
        }
        $psi = new LocalMachine($machine);
      }
      else {
        $psi = new RemoteMachine($machine);
      }
      if (!$psi->initialize()) {
        $psi = NULL;
      }
      $this->allMachines[$key] = $psi;
    }
  }
  
  /**
   * Retrieves information from the remote server about the state of the 
   *   cluster.
   * 
   * @return boolean
   *   TRUE if the cluster info was received, otherwise FALSE.
   */
  private function initClusterInfo() {
    $cmd = 'sudo crm_mon -1';
    foreach ($this->allMachines as $machine) {
      if (!empty($machine) && $machine instanceof PhysicalServerInterface) {
        $machine->executeCommand($cmd, array(), $out);
        if (!empty($out)) {
          $this->parseClusterInfo($out);
          return TRUE;
        }
      }
    }
    return FALSE;
  }
  
  /**
   * Parses the cluster information for relevant data.
   * 
   * @param array $info
   *   An array of strings as returned from the crm_mon command.
   */
  private function parseClusterInfo($info) {
    foreach ($info as $line) {
      $pieces = explode(':', $line);
      $token = trim($pieces[0]);
      switch ($token) {
        case 'Current DC':
          $parsed = explode(' ', trim($pieces[1]));
          $this->dcNode = trim($parsed[0]);
          break;
        case 'Online:':
          $this->onlineNodes = explode(' ', trim($pieces[1], ' []'));
          break;
      }
    }
  }
  
  /**
   * Retrieves all the relevant cluster machines.
   * 
   * @param string $type
   *   One of the following modes:
   *   - PACEMAKER_MODE_ALL: Returns all defined servers. If one is not 
   *     available, then it is considered an error.
   *   - PACEMAKER_MODE_ONLINE_ONLY: Returns all defined servers that are
   *     currently marked as online by Pacemaker. If an online server is not
   *     defined or able to be connected to, it is considered an error.
   *   - PACEMAKER_MODE_DC_ONLY: Returns only the decision node. If the node
   *     is not available or cannot be reached, it is an error.
   * @return array
   *   An array of PhysicalServerInterface objects that meet the requirements
   *   outlined by $type. Returns FALSE if there is an error picking a machine.   * 
   */
  private function getClusterMachines($type) {
    $machines = array();
    switch ($type) {
      case PACEMAKER_MODE_ALL:
        foreach ($this->allMachines as $key => $machine) {
          if (empty($machine)) {
            return FALSE;
          }
          $machines[$key] = $machine;
        }
        break;
      case PACEMAKER_MODE_ONLINE_ONLY:
        foreach ($this->onlineNodes as $node) {
          if (!empty($this->allMachines[$node])) {
            $machines[$node] = $this->allMachines[$node];
          }
          else {
            return FALSE;
          }
        }
        break;
      case PACEMAKER_MODE_DC_ONLY:
        if (!empty($this->allMachines[$this->dcNode])) {
          $machines[$this->dcNode] = $this->allMachines[$this->dcNode];
        }
        else {
          return FALSE;
        }
        break;
      default:
        return FALSE;
    }
    return $machines;
  }
  
}