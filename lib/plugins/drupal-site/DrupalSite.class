<?php
/**
 * @file Provides the DrupalSite class.
 * 
 * @defgroup site_settings Drupal Site Settings
 * These are settings that can be accessed via a DrupalSite object. Note that
 * some of them are only provided by certain plugins and may be empty.
 * 
 * @defgroup site_tokens Drupal Site Tokens
 * These are tokens that can be used in replacement patterns.
 * @see DrupalSite:replaceTokens().
 */

/**
 * Contains the previous build ID.
 * 
 * @ingroup site_settings
 */
define('SITE_LAST_BUILD_ID', 'last-build-id');

/**
 * Fired to remove everything that belongs with a site.
 * 
 * @ingroup events
 */
define('EVENT_REMOVE_ALL', 'remove-all');

/**
 * Whether or not the site is local.
 * 
 * @ingroup site_settings
 */
define('SITE_IS_LOCAL', 'is_local');

/**
 * The build directory.
 * 
 * @ingroup site_settings
 */
define('SITE_BUILD_DIR', 'build_dir');

/**
 * The unique build name.
 * 
 * @ingroup site_settings
 */
define('SITE_BUILD_NAME', 'build_name');

/**
 * A list of build IDs.
 * 
 * @ingroup site_settings
 */
define('SITE_BUILD_IDS', 'build_ids');

/**
 * The latest build ID.
 * 
 * @ingroup site_settings
 */
define('SITE_LATEST_BUILD_ID', 'latest_build_id');

/**
 * A list of subsite names.
 * 
 * @ingroup site_settings
 */
define('SITE_EXISTING_SITES', 'existing_sites');

/**
 * A list of subsites.
 * 
 * @ingroup site_settings
 */
define('SITE_SUBSITE_LIST', 'subsite_list');

/**
 * Whether or not the site is instaleld.
 * 
 * @ingroup site_settings
 */
define('SITE_IS_INSTALLED', 'is_installed');

/**
 * A token for SITE_BUILD_NAME.
 * 
 * @ingroup site_tokens
 */
define('SITE_TOKEN_BUILD_NAME', 'BUILD_NAME');

/**
 * A token for SITE_BUILD_DIR.
 * 
 * @ingroup site_tokens
 */
define('SITE_TOKEN_BUILD_DIR', 'BUILD_DIRECTORY');

/**
 * Stores information about a site installation.
 */
class DrupalSite extends GenericDrupalEntity {
 
  /**
   * Cached subsites.
   * 
   * @var array
   */
  private $cachedSubSites = array();
  
  /**
   * Constructs an instance of DrupalSite.
   * 
   * You should use the factory method instead.
   * 
   * @param string $name
   *   The build name.
   * @param string $folder
   *   The root folder for the build.
   * @param boolean $local
   *   Whether or not this is a local build.
   */
  private function __construct($name, $folder, $local = FALSE) {
    $this->setSetting(SITE_IS_LOCAL, !!$local);
    $this->setSetting(SITE_BUILD_DIR, $folder);
    $this->setSetting(SITE_BUILD_NAME, $name);
    $this->setSetting(SITE_BUILD_IDS, array());
    $this->setSetting(SITE_LATEST_BUILD_ID, NULL);
    $this->setSetting(SITE_PRIMARY_URL, NULL);
    $this->setSetting(SITE_EXTRA_URLS, array());
    $this->setSetting(SITE_EXISTING_SITES, array('default'));
    $this->setToken(SITE_TOKEN_BUILD_NAME, $name);
    $this->setToken(SITE_TOKEN_BUILD_DIR, $folder);
    $this->setToken(SITE_TOKEN_UUID, $this->uuid());
  }
  
  protected function getConfigurationPath() {
    return assemble_path($this->getBuildFolder(), 'webcms.scf');
  }
  
  protected function getOldConfigurationPaths() {
    return array(
      assemble_path($this->getBuildFolder(), 'webcms.cfg'),
    );
  }
  /**
   * Retrieves a subsite.
   * 
   * @param string $subsiteID
   *   A subsite ID.
   * 
   * @return DrupalSubSite
   *   An instance of DrupalSubSite tied to $subsiteID.
   */
  public function getSubSite($subsiteID) {
    if (!isset($this->cachedSubSites[$subsiteID])) {
      $this->cachedSubSites[$subsiteID] = new DrupalSubSite($this, $subsiteID);
      $this->cachedSubSites[$subsiteID]->loadSettings();
    }
    return $this->cachedSubSites[$subsiteID];
  }
  
  public function uuid() {
    return $this->getBuildName();
  }
  
  /**
   * Registers a new subsite after it has been successfully built.
   * 
   * @param DrupalSubSite $subsite
   *   The subsite object.
   */
  public function registerSubSite(DrupalSubSite $subsite) {
    $this->appendSettingValue(SITE_SUBSITE_LIST, $subsite->getSubSiteID());
  }
  
  /**
   * Retrieves a list of subsite IDs that can be used with getSubSite().
   * 
   * @return array
   *   An array of subsite IDs.
   */
  public function getSubSites() {
    return $this->getSetting(SITE_SUBSITE_LIST);
  }
    
  /**
   * Retrieves the build folder.
   * 
   * @return string
   *   The path to the build folder.
   */
  public function getBuildFolder() {
    return $this->getSetting(SITE_BUILD_DIR);
  }
  
  /**
   * Retrieves the build name.
   * 
   * @return string
   *   The name of the build.
   */
  public function getBuildName() {
    return $this->getSetting(SITE_BUILD_NAME);
  }
  
  /**
   * Registers a new build ID.
   * 
   * @param string $buildID
   *   The build ID.
   */
  public function registerNewBuildID($buildID) {
    $this->setSetting(SITE_LAST_BUILD_ID, $this->getSetting(SITE_LATEST_BUILD_ID));
    $this->setSetting(SITE_LATEST_BUILD_ID, $buildID);
    $this->appendSettingValue(SITE_BUILD_IDS, $buildID);
  }
  
  /**
   * Deletes a build ID from the list of build IDs and resets the last/latest
   * build IDs.
   * 
   * @param string $buildID
   *   The build ID to remove.
   */
  public function deleteBuildID($buildID) {
    $ids = $this->getSetting(SITE_BUILD_IDS);
    $this->setSetting(SITE_BUILD_IDS, array());
    foreach ($ids as $id) {
      if ($id !== $buildID) {
        $this->registerNewBuildID($id);
      }
    }
  }
  
  /**
   * Retrieves the current build ID.
   * 
   * @return string
   *   The current build ID.
   */
  public function getBuildID() {
    return $this->getSetting(SITE_LATEST_BUILD_ID);
  }
  
  /**
   * Retrieves the previous build ID.
   * 
   * @return string 
   *   The previous build ID.
   */
  public function getPreviousBuildID() {
    return $this->getSetting(SITE_LAST_BUILD_ID);
  }
  
  /**
   * Triggers the deletion of a specific build.
   * 
   * @param EventManagerInterface $events
   *   An event manager to fire events from.
   * @param string $buildID
   *   The ID of the build to delete.
   * 
   * @return boolean
   *   TRUE if the build was deleted, otherwise FALSE.
   */
  public function deleteBuild(EventManagerInterface $events, $buildID) {
    $context = (object) array(
      'site' => $this,
      'buildID' => $buildID,
      'handled' => FALSE,
      'success' => TRUE,
    );
    $events->fireEvent(EVENT_DELETE_BUILD, $context);
    $this->deleteBuildID($buildID);
    return $context->success;
  }
  
  
  
  /**
   * Converts a Drupal URL path (eg example.com/mydrupal) to a Drupal site name
   * (eg example.com.mydrupal).
   * 
   * @param string $url
   *   The Drupal URL path to convert.
   * 
   * @return string
   *   The Drupal site name equivalent.
   */
  public static function convertURLToSiteName($url) {
    $sitename = $url;
    // Remove protocol
    if (($protocol = strpos($sitename, '//')) !== FALSE) {
      $sitename = substr($sitename, $protocol + 2);
    }
    // No question marks
    if (($query = strpos($sitename, '?')) !== FALSE) {
      $sitename = substr($sitename, 0, $query);
    }
    // No fragments
    if (($frag = strpos($sitename, '#')) !== FALSE) {
      $sitename = substr($sitename, 0, $frag);
    }
    // No port numbers
    preg_replace('`:\d{1,}`', '', $sitename);
    // Convert slashes to dots
    $sitename = str_replace('/', '.', $sitename);
    return $sitename;
  }
  
  /**
   * Creates a site object.
   * 
   * @param Configuration $config
   *   The configuration object. 
   * @param string $name
   *   The name of the site.
   * @param boolean $isLocal
   *   Whether or not the site is a local site.
   * 
   * @return DrupalSite
   *   An instance of DrupalSite or NULL if the information provided is invalid.
   */
  public static function createSite(Configuration $config, $name, $isLocal) {
    $path = $config->getConfig(CONFIG_BUILD_DIRECTORY);
    if ($isLocal) {
      $path = getcwd();
    }
    $path = expand_path($path);
    if (!is_writable($path)) {
      return NULL;
    }
    if (!$isLocal) {
      $path = assemble_path($path, $name);
    }
    return new DrupalSite($name, $path, $isLocal);
  }
  
}
