<?php
/**
 * @file Provides the DrupalSite class.
 * 
 * @defgroup site_settings Drupal Site Settings
 * These are settings that can be accessed via a DrupalSite object. Note that
 * some of them are only provided by certain plugins and may be empty.
 * 
 * @defgroup site_tokens Drupal Site Tokens
 * These are tokens that can be used in replacement patterns.
 * @see DrupalSite:replaceTokens().
 */

/**
 * Stores information about a site installation.
 */
class DrupalSite extends GenericDrupalEntity {
 
  /**
   * Cached subsites.
   * 
   * @var array
   */
  private $cachedSubSites = array();
  
  /**
   * Temporary holding point for a subsite that is currently built
   * in case it needs to be accessed.
   * 
   * @var DrupalSubSite
   */
  private $inProgressSubSite = NULL;
    
  /**
   * Constructs an instance of DrupalSite.
   * 
   * You should use the factory method instead.
   * 
   * @param string $name
   *   The build name.
   * @param string $folder
   *   The root folder for the build.
   * @param boolean $local
   *   Whether or not this is a local build.
   */
  private function __construct($name, $folder, $local = FALSE) {
    $this->setSetting(SITE_IS_LOCAL, !!$local);
    $this->setSetting(SITE_BUILD_DIR, $folder);
    $this->setSetting(SITE_BUILD_NAME, $name);
    $this->setSetting(SITE_BUILD_IDS, array());
    $this->setSetting(SITE_LATEST_BUILD_ID, NULL);
    $this->setSetting(SITE_PRIMARY_URL, NULL);
    $this->setSetting(SITE_EXTRA_URLS, array());
    $this->setSetting(SITE_EXISTING_SITES, array('default'));
    $this->setToken(SITE_TOKEN_BUILD_NAME, $name);
    $this->setToken(SITE_TOKEN_BUILD_DIR, $folder);
    $this->setToken(SITE_TOKEN_UUID, $this->uuid());
  }
  
  public function isLocal() {
    return $this->getSetting(SITE_IS_LOCAL, FALSE);
  }
  
  /**
   * Allows the site to use the temporary subsite object before it is
   * registered properly after creation.
   * 
   * @param DrupalSubSite $subsite
   *   The subsite being created.
   */
  public function registerTemporarySubSite(DrupalSubSite $subsite) {
    $this->inProgressSubSite = $subsite;
  }
  
  protected function getConfigurationPath() {
    return assemble_path($this->getBuildFolder(), 'webcms.scf');
  }
  
  protected function getOldConfigurationPaths() {
    return array(
      assemble_path($this->getBuildFolder(), 'webcms.cfg'),
    );
  }
  /**
   * Retrieves a subsite.
   * 
   * @param string $subsiteID
   *   A subsite ID.
   * 
   * @return DrupalSubSite
   *   An instance of DrupalSubSite tied to $subsiteID.
   */
  public function getSubSite($subsiteID) {
    if (!isset($this->cachedSubSites[$subsiteID])) {
      $this->cachedSubSites[$subsiteID] = new DrupalSubSite($this, $subsiteID);
      $this->cachedSubSites[$subsiteID]->loadSettings();
    }
    return $this->cachedSubSites[$subsiteID];
  }
  
  public function primeSubSiteCache($subsiteID, DrupalSubSite $site) {
    if (!isset($this->cachedSubSites[$subsiteID])) {
      $this->cachedSubSites[$subsiteID] = $site;
    }
    DependencyManager::inject($site);
  }
  
  public function setDeletionFlag() {
    parent::setDeletionFlag();
    $ids = $this->getSubSites();
    foreach ($ids as $id) {
      $subsite = $this->getSubSite($id);
      $subsite->setDeletionFlag();
    }
  }
  
  /**
   * Deletes a subsite from this site's reference.
   * 
   * @param DrupalSubSite $subsite
   *   Subsite to be deleted.
   */
  public function deleteSubSite(DrupalSubSite $subsite) {
    $id = $subsite->getSubSiteID();
    $subsites = $this->getSetting(SITE_SUBSITE_LIST);
    $newSubsites = array();
    foreach ($subsites as $subsite) {
      if ($subsite !== $id) {
        $newSubsites[$subsite] = $subsite;
      }
    }
    $this->setSetting(SITE_SUBSITE_LIST, $subsites);
    if (isset($this->cachedSubSites[$id])) {
      unset($this->cachedSubSites[$id]);
    }
  }
  
  public function uuid() {
    return $this->getBuildName();
  }
  
  public function getDynamicTokens() {
    $tokens = array(
      SITE_TOKEN_RECURSIVE_DOMAINS => implode(" ", $this->getRecursiveDomains()),
    );
    return $tokens + parent::getDynamicTokens();
  }
  
  /**
   * Retrieves the sum of all the domains of this site and all it's subsites.
   * 
   * @return array
   *   An array of unique domains used by this site and all of it's subsites.
   */
  public function getRecursiveDomains() {
    if ($this->isDeleted()) {
      return array();
    }
    $domains = $this->getSetting(SITE_SETTING_ALL_DOMAINS);
    if (empty($domains)) {
      return array();
    }
    $subsiteIDs = $this->getSubSites();
    if (!empty($subsiteIDs)) {
      foreach ($subsiteIDs as $subsiteID) {
        $subsite = $this->getSubSite($subsiteID);
        if (!$subsite->isDeleted() && $subsite->exists() && empty($subsite->getSetting(SITE_SETTING_IS_CROSSLINKED))) {
          foreach ($subsite->getSetting(SITE_SETTING_ALL_DOMAINS) as $domain) {
            $domains[] = $domain;
          }
        }
      }
    }
    if (!empty($this->inProgressSubSite) && empty($this->inProgressSubSite->getSetting(SITE_SETTING_IS_CROSSLINKED))) {
      foreach ($this->inProgressSubSite->getSetting(SITE_SETTING_ALL_DOMAINS) as $domain) {
        $domains[] = $domain;
      }
    }
    return array_unique($domains);
  }
  
  /**
   * Registers a new subsite after it has been successfully built.
   * 
   * @param DrupalSubSite $subsite
   *   The subsite object.
   */
  public function registerSubSite(DrupalSubSite $subsite) {
    $this->appendSettingValue(SITE_SUBSITE_LIST, $subsite->getSubSiteID());
  }
  
  /**
   * Retrieves a list of subsite IDs that can be used with getSubSite().
   * 
   * @return array
   *   An array of subsite IDs.
   */
  public function getSubSites() {
    return $this->getSetting(SITE_SUBSITE_LIST, array());
  }
  
  /**
   * Retrieves all rootlinks for this site and it's subsites.
   * 
   * @return array
   *   An array of rootlinks.
   */
  public function getAllRootLinks() {
    $rootlinks = $this->getRootLinks();
    $subsites = $this->getSubSites();
    foreach ($subsites as $subsite) {
      $entity = $this->getSubSite($subsite);
      $rootlinks += $entity->getRootLinks();
    }
  }
    
  /**
   * Retrieves the build folder.
   * 
   * @return string
   *   The path to the build folder.
   */
  public function getBuildFolder() {
    return $this->getSetting(SITE_BUILD_DIR);
  }
  
  /**
   * Retrieves the build name.
   * 
   * @return string
   *   The name of the build.
   */
  public function getBuildName() {
    return $this->getSetting(SITE_BUILD_NAME);
  }
  
  /**
   * Registers a new build ID.
   * 
   * @param string $buildID
   *   The build ID.
   */
  public function registerNewBuildID($buildID) {
    $this->setSetting(SITE_LAST_BUILD_ID, $this->getSetting(SITE_LATEST_BUILD_ID));
    $this->setSetting(SITE_LATEST_BUILD_ID, $buildID);
    $this->appendSettingValue(SITE_BUILD_IDS, $buildID);
  }
  
  /**
   * Deletes a build ID from the list of build IDs and resets the last/latest
   * build IDs.
   * 
   * @param string $buildID
   *   The build ID to remove.
   */
  public function deleteBuildID($buildID) {
    $ids = $this->getSetting(SITE_BUILD_IDS);
    $this->setSetting(SITE_BUILD_IDS, array());
    $this->setSetting(SITE_LAST_BUILD_ID, NULL);
    $this->setSetting(SITE_LATEST_BUILD_ID, NULL);
    foreach ($ids as $id) {
      if ($id !== $buildID) {
        $this->registerNewBuildID($id);
      }
    }
  }
  
  /**
   * Retrieves the current build ID.
   * 
   * @return string
   *   The current build ID.
   */
  public function getBuildID() {
    return $this->getSetting(SITE_LATEST_BUILD_ID);
  }
  
  /**
   * Retrieves the previous build ID.
   * 
   * @return string 
   *   The previous build ID.
   */
  public function getPreviousBuildID() {
    return $this->getSetting(SITE_LAST_BUILD_ID);
  }
  
  /**
   * Triggers the deletion of a specific build.
   * 
   * @param EventManagerInterface $events
   *   An event manager to fire events from.
   * @param string $buildID
   *   The ID of the build to delete.
   * 
   * @return boolean
   *   TRUE if the build was deleted, otherwise FALSE.
   */
  public function deleteBuild(EventManagerInterface $events, $buildID) {
    $event = new DrupalSiteEvent($this, FALSE, array(
      'buildID' => $buildID,
    ));
    $events->fireEvent(EVENT_DELETE_BUILD, $event);
    $this->deleteBuildID($buildID);
    return $event->success();
  }
  
  
  
  /**
   * Converts a Drupal URL path (eg example.com/mydrupal) to a Drupal site name
   * (eg example.com.mydrupal).
   * 
   * @param string $url
   *   The Drupal URL path to convert.
   * 
   * @return string
   *   The Drupal site name equivalent.
   */
  public static function convertURLToSiteName($url) {
    $sitename = $url;
    // Remove protocol
    if (($protocol = strpos($sitename, '//')) !== FALSE) {
      $sitename = substr($sitename, $protocol + 2);
    }
    // No question marks
    if (($query = strpos($sitename, '?')) !== FALSE) {
      $sitename = substr($sitename, 0, $query);
    }
    // No fragments
    if (($frag = strpos($sitename, '#')) !== FALSE) {
      $sitename = substr($sitename, 0, $frag);
    }
    // No port numbers
    preg_replace('`:\d{1,}`', '', $sitename);
    // Convert slashes to dots
    $sitename = str_replace('/', '.', $sitename);
    return $sitename;
  }
  
  /**
   * Creates a site object.
   * 
   * @param Configuration $config
   *   The configuration object. 
   * @param string $name
   *   The name of the site.
   * @param boolean $isLocal
   *   Whether or not the site is a local site.
   * 
   * @return DrupalSite
   *   An instance of DrupalSite or NULL if the information provided is invalid.
   */
  public static function createSite(Configuration $config, $name, $isLocal) {
    $path = $config->getConfig(CONFIG_BUILD_DIRECTORY);
    if ($isLocal) {
      $path = TOOLKIT_EXECUTION_PATH;
    }
    $path = expand_path($path);
    if (!is_writable($path)) {
      return NULL;
    }
    if (!$isLocal) {
      $path = assemble_path($path, $name);
    }
    $site = new DrupalSite($name, $path, $isLocal);
    DependencyManager::inject($site);
    return $site;
  }
  
  /**
   * Retrieves an array of sites that exist in CONFIG_BUILD_DIRECTORY.
   * 
   * @param Configuration $config
   *   Configuration object to determine the build directory path.
   * 
   * @return array
   *   An array of valid DrupalSites.
   */
  public static function findSites(Configuration $config) {
    $sites = array();
    $path = $config->getConfig(CONFIG_BUILD_DIRECTORY);
    $path = expand_path($path);
    $handle = opendir($path);
    if (!empty($handle)) {
      while (($file = readdir($handle)) !== FALSE) {
        if ($file != "." && $file != "..") {
          $p = assemble_path($path, $file);
          $site = new DrupalSite($file, $p);
          if ($site->exists()) {
            $site->loadSettings();
            $sites[$file] = $site;
          }
        }
      }
      closedir($handle);
    }
    ksort($sites);
    return $sites;
  }
  
}
