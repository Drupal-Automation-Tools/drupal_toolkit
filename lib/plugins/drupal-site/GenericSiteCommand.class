<?php
/**
 * @file Defines the GenericSiteCommand abstract class.
 */

/**
 * String token for when the site object could not be built.
 * 
 * @ingroup strings
 */  
define('STRING_ERROR_NO_SITE', 'drupal_site.error.no-site');

/**
 * String token for when the site object is out of date.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_OLD_SITE', 'drupal_site.error.old-site');

/**
 * String token for when a site does not exist (and one is required).
 * 
 * @ingroup strings
 */
define('STRING_ERROR_MISSING_SITE', 'drupal_site.error.missing-site');

/**
 * String token for when a site exists (and we don't want to overwrite it).
 * 
 * @ingroup strings
 */
define('STRING_ERROR_ALREADY_SITE', 'drupal_site.error.site-exists');

/**
 * String token for if the site's configuration file could not be saved.
 * 
 * @ingroup strings
 */
define('STRING_COULD_NOT_SAVE_SITE', 'drupal_site.error.no-save');

/**
 * String token for when the subsite object could not be built.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_NO_SUBSITE', 'drupal_site.error.no-subsite');

/**
 * String token for when the subsite exists and we don't want to overwrite it.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_OLD_SUBSITE', 'drupal_site.error.old-subsite');

/**
 * String token for when the subsite does not exist.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_MISSING_SUBSITE', 'drupal_site.error.missing-subsite');

/**
 * String token for when the subsite already exists and it should not.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_ALREADY_SUBSITE', 'drupal_site.error.already-subsite');

/**
 * Provides a base for commands that need to work with sites.
 */
abstract class GenericSiteCommand extends GenericCommand {
  
  /**
   * Retrieves the build name specified by the argument.
   * 
   * @param int $pos 
   *   The position of the argument in the build name.
   * 
   * @return string
   *   The build name.
   */
  protected function getBuildName($pos = 1) {
    return $this->sanitizeName($this->args()->getArg($pos));
  }
  
  /**
   * Retrieves the build's subsite name as specified by the argument.
   * 
   * @param int $pos
   *   The position of the argument for the build subsite name.
   * 
   * @return string
   *   The build subsite name.
   */
  protected function getSubSiteName($pos = 2) {
    return $this->sanitizeName($this->args()->getArg($pos));
  }
  
  /**
   * Sanitizes the site and subsite build names.
   * 
   * Currently this involves:
   * - replace all non alpha-numerical characters with underscores
   * - replace sets of two or more underscores with a single underscore
   * - trim all underscores off the ends.
   * 
   * @param string $name
   *   A name to sanitize.
   * 
   * @return string
   *   The sanitized site/subsite name.
   */
  private function sanitizeName($name) {
    return strtolower(trim(preg_replace('`_{2,}`', '_', preg_replace('[^A-Za-z0-9_]', '_', $name)), '_'));
  }
  
  /**
   * Checks to see if the site should be local.
   * 
   * @return boolean
   *   TRUE if the site should be local, otherwise FALSE.
   */
  protected function isLocal() {
    $config = $this->config()->getConfig(CONFIG_ALLOW_LOCAL_SITES);
    if ($config == LOCAL_SITES_ALWAYS) {
      return TRUE;
    }
    elseif ($config == LOCAL_SITES_NEVER) {
      return FALSE;
    }
    return $this->args()->hasOption(ARG_IS_LOCAL);
  }
  
  /**
   * Verifies that the site exists and can be worked on with this version of
   * the toolkit.
   * 
   * @param string $name
   *   The name of the site. If not specified, it will be loaded via getSite().
   * 
   * @return boolean
   *   TRUE if the site is present, otherwise FALSE.
   */
  protected function requireSite($name = NULL) {
    $site = $this->getSite($name);
    if (empty($site)) {
      $this->error(STRING_ERROR_NO_SITE);
      return FALSE;
    }
    if ($site->existsBackwards()) {
      $this->error(STRING_ERROR_OLD_SITE);
      return FALSE;
    }
    if (!$site->exists()) {
      $this->error(STRING_ERROR_MISSING_SITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Verifies that the subsite exists.
   * 
   * @param string $siteName
   *   The name of the parent site, or NULL to load it from the default location.
   * @param string $subSiteName
   *   The name of the subsite, or NULL to load it from the default location.
   * 
   * @return boolean
   *   TRUE if the subsite exists and does not need to be migrated, otherwise
   *   returns FALSE.
   */
  protected function requireSubSite($siteName = NULL, $subSiteName = NULL) {
    if (!$this->requireSite($siteName)) {
      return FALSE;
    }
    $subsite = $this->getSubSite($siteName, $subSiteName);
    if (empty($subsite)) {
      $this->error(STRING_ERROR_NO_SUBSITE);
      return FALSE;
    }
    if ($subsite->existsBackwards()) {
      $this->error(STRING_ERROR_OLD_SUBSITE);
      return FALSE;
    }
    if (!$subsite->exists()) {
      $this->error(STRING_ERROR_MISSING_SUBSITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Verifies that the subsite does not exists.
   * 
   * @param string $siteName
   *   The name of the parent site, or NULL to load it from the default location.
   * @param string $subSiteName
   *   The name of the subsite, or NULL to load it from the default location.
   * 
   * @return boolean
   *   TRUE if the subsite exists and does not need to be migrated, otherwise
   *   returns FALSE.
   */
  protected function requireNoSubSite($siteName = NULL, $subSiteName = NULL) {
    if (!$this->requireSite($siteName)) {
      return FALSE;
    }
    $subsite = $this->getSubSite($siteName, $subSiteName);
    if (empty($subsite)) {
      $this->error(STRING_ERROR_NO_SUBSITE);
      return FALSE;
    }
    if ($subsite->existsBackwards()) {
      $this->error(STRING_ERROR_OLD_SUBSITE);
      return FALSE;
    }
    if ($subsite->exists()) {
      $this->error(STRING_ERROR_ALREADY_SUBSITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Requires that the site does not exist.
   * 
   * @param string $name
   *   The name of the site. If not specified, it will be loaded via getSite().
   * 
   * @return boolean
   *   TRUE if the site is not present, otherwise FALSE.
   */
  protected function requireNoSite($name = NULL) {
    $site = $this->getSite($name);
    if (empty($site)) {
      $this->error(STRING_ERROR_NO_SITE);
      return FALSE;
    }
    if ($site->exists() || $site->existsBackwards()) {
      $this->error(STRING_ERROR_ALREADY_SITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Retrieves the site specified by the given name.
   * 
   * @param string $name
   *   The name of the build. If none is specified, then it is retrieved via
   *   getBuildName().
   * 
   * @return DrupalSite
   *   A DrupalSite object or NULL if one could not be loaded.
   * 
   * @see DrupalSite::createSite()
   */
  protected function getSite($name = NULL) {
    if (empty($name)) {
      $name = $this->getBuildName();
    }
    return DrupalSite::createSite($this->config(), $name, $this->isLocal());
  }
  
  /**
   * Retrieves a subsite object.
   * 
   * @param string $parentName
   *   The parent name, or leave NULL to auto-load it from the default 
   *   position.
   * @param string $subsiteName
   *   The subsite name, or leave NULL to auto-load it from the default
   *   position.
   * 
   * @return DrupalSubSite
   *   The subsite object.
   */
  protected function getSubSite($parentName = NULL, $subsiteName = NULL) {
    if (empty($subsiteName)) {
      $subsiteName = $this->getSubSiteName();
    }
    return new DrupalSubSite($this->getSite($parentName), $subsiteName);
  }
  
  public function verifyRequirements() {
    // Most commands will require these things. If your plugin does not, then
    // you can override this completely.
    return $this->requireCommand('mysql')
        && $this->requireCommand('git')
        && $this->requireCommand('drush')
        && $this->requireFunction('exec')
        && $this->requireFunction('rename')
        && $this->requireFunction('copy')
        && $this->requireFunction('symlink');
  }
  
}