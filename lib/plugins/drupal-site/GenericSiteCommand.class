<?php
/**
 * @file Defines the GenericSiteCommand abstract class.
 */

/**
 * Provides a base for commands that need to work with sites.
 */
abstract class GenericSiteCommand extends GenericCommand {
  
  /**
   * Caches the loaded site object to prevent multiple calls for building
   * the object and loading settings.
   * 
   * @var DrupalSite
   */
  private $loadedSite = NULL;
  
  /**
   * Caches the loaded subsite object to prevent multiple calls for building
   * the object and loading settings.
   * 
   * @var DrupalSubSite
   */
  private $loadedSubSite = NULL;
  
  /**
   * Retrieves the build name specified by the argument.
   * 
   * @param int $pos 
   *   The position of the argument in the build name.
   * 
   * @return string
   *   The build name.
   */
  protected function getBuildName($pos = 1) {
    return $this->sanitizeName($this->args()->getArg($pos));
  }
  
  /**
   * Retrieves the build's subsite name as specified by the argument.
   * 
   * @param int $pos
   *   The position of the argument for the build subsite name.
   * 
   * @return string
   *   The build subsite name.
   */
  protected function getSubSiteName($pos = 2) {
    return $this->sanitizeName($this->args()->getArg($pos));
  }
  
  /**
   * Sanitizes the site and subsite build names.
   * 
   * Currently this involves:
   * - replace all non alpha-numerical characters with underscores
   * - replace sets of two or more underscores with a single underscore
   * - trim all underscores off the ends.
   * 
   * @param string $name
   *   A name to sanitize.
   * 
   * @return string
   *   The sanitized site/subsite name.
   */
  private function sanitizeName($name) {
    return strtolower(trim(preg_replace('`_{2,}`', '_', preg_replace('[^A-Za-z0-9_]', '_', $name)), '_'));
  }
  
  /**
   * Checks to see if the site should be local.
   * 
   * @return boolean
   *   TRUE if the site should be local, otherwise FALSE.
   */
  protected function isLocal() {
    $config = $this->config()->getConfig(CONFIG_ALLOW_LOCAL_SITES);
    if ($config == LOCAL_SITES_ALWAYS) {
      return TRUE;
    }
    elseif ($config == LOCAL_SITES_NEVER) {
      return FALSE;
    }
    return $this->args()->hasOption(ARG_IS_LOCAL, TRUE);
  }
  
  /**
   * Verifies that the site exists and can be worked on with this version of
   * the toolkit.
   * 
   * @param string $name
   *   The name of the site. If not specified, it will be loaded via getSite().
   * 
   * @return boolean
   *   TRUE if the site is present, otherwise FALSE.
   */
  protected function requireSite($name = NULL) {
    $site = $this->getSite($name);
    if (empty($site)) {
      $this->error(STRING_ERROR_NO_SITE);
      return FALSE;
    }
    if ($site->existsBackwards()) {
      $this->error(STRING_ERROR_OLD_SITE);
      return FALSE;
    }
    if (!$site->exists()) {
      $this->error(STRING_ERROR_MISSING_SITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Verifies that the subsite exists.
   * 
   * @param string $siteName
   *   The name of the parent site, or NULL to load it from the default location.
   * @param string $subSiteName
   *   The name of the subsite, or NULL to load it from the default location.
   * 
   * @return boolean
   *   TRUE if the subsite exists and does not need to be migrated, otherwise
   *   returns FALSE.
   */
  protected function requireSubSite($siteName = NULL, $subSiteName = NULL) {
    if (!$this->requireSite($siteName)) {
      return FALSE;
    }
    $subsite = $this->getSubSite($siteName, $subSiteName);
    if (empty($subsite)) {
      $this->error(STRING_ERROR_NO_SUBSITE);
      return FALSE;
    }
    if ($subsite->existsBackwards()) {
      $this->error(STRING_ERROR_OLD_SUBSITE);
      return FALSE;
    }
    if (!$subsite->exists()) {
      $this->error(STRING_ERROR_MISSING_SUBSITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Verifies that the subsite does not exists.
   * 
   * @param string $siteName
   *   The name of the parent site, or NULL to load it from the default location.
   * @param string $subSiteName
   *   The name of the subsite, or NULL to load it from the default location.
   * 
   * @return boolean
   *   TRUE if the subsite exists and does not need to be migrated, otherwise
   *   returns FALSE.
   */
  protected function requireNoSubSite($siteName = NULL, $subSiteName = NULL) {
    if (!$this->requireSite($siteName)) {
      return FALSE;
    }
    $subsite = $this->getSubSite($siteName, $subSiteName);
    if (empty($subsite)) {
      $this->error(STRING_ERROR_NO_SUBSITE);
      return FALSE;
    }
    if ($subsite->existsBackwards()) {
      $this->error(STRING_ERROR_OLD_SUBSITE);
      return FALSE;
    }
    if ($subsite->exists()) {
      $this->error(STRING_ERROR_ALREADY_SUBSITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Requires that the site does not exist.
   * 
   * @param string $name
   *   The name of the site. If not specified, it will be loaded via getSite().
   * 
   * @return boolean
   *   TRUE if the site is not present, otherwise FALSE.
   */
  protected function requireNoSite($name = NULL) {
    $site = $this->getSite($name);
    if (empty($site)) {
      $this->error(STRING_ERROR_NO_SITE);
      return FALSE;
    }
    if ($site->exists() || $site->existsBackwards()) {
      $this->error(STRING_ERROR_ALREADY_SITE);
      return FALSE;
    }
    return TRUE;
  }
  
  /**
   * Retrieves the site specified by the given name.
   * 
   * @param string $name
   *   The name of the build. If none is specified, then it is retrieved via
   *   getBuildName().
   * 
   * @return DrupalSite
   *   A DrupalSite object or NULL if one could not be loaded.
   * 
   * @see DrupalSite::createSite()
   */
  protected function getSite($name = NULL) {
    if (empty($this->loadedSite)) {
      if (empty($name)) {
        $name = $this->getBuildName();
      }
      $this->loadedSite = DrupalSite::createSite($this->config(), $name, $this->isLocal());
      if (!empty($this->loadedSite)) {
        $this->loadedSite->loadSettings();
        DrupalSiteEvent::fireSiteEvent($this->strings(), $this->out(), $this->events(), array(
          'entity' => $this->loadedSite,
          'name' => EVENT_DRUPAL_SITE_CONSTRUCTOR,
          'optional' => TRUE,
        ));
      }
    }
    return $this->loadedSite;
  }
  
  /**
   * Retrieves a subsite object.
   * 
   * @param string $parentName
   *   The parent name, or leave NULL to auto-load it from the default 
   *   position.
   * @param string $subsiteName
   *   The subsite name, or leave NULL to auto-load it from the default
   *   position.
   * 
   * @return DrupalSubSite
   *   The subsite object.
   */
  protected function getSubSite($parentName = NULL, $subsiteName = NULL) {
    if (empty($this->loadedSubSite)) {
      if (empty($subsiteName)) {
        $subsiteName = $this->getSubSiteName();
      }
      $this->loadedSubSite = new DrupalSubSite($this->getSite($parentName), $subsiteName);
      if (!empty($this->loadedSubSite)) {
        $this->loadedSubSite->loadSettings();
        DrupalSiteEvent::fireSiteEvent($this->strings(), $this->out(), $this->events(), array(
          'entity' => $this->loadedSubSite,
          'name' => EVENT_DRUPAL_SITE_CONSTRUCTOR,
          'optional' => TRUE,
        ));
      }
    }
    return $this->loadedSubSite;
  }
  
  public function verifyRequirements() {
    // Most commands will require these things. If your plugin does not, then
    // you can override this completely.
    return $this->requireCommand('mysql')
        && $this->requireCommand('git')
        && $this->requireCommand('drush')
        && $this->requireFunction('exec')
        && $this->requireFunction('rename')
        && $this->requireFunction('copy')
        && $this->requireFunction('symlink');
  }
  
  /**
   * Executes an array of step commands.
   * 
   * @param array $steps
   *   An array of step arrays:
   *   - event: the name of the event to fire
   *   - optional: set to TRUE to make the step optional
   *   - die: set to the error code to die with or 0 to not die
   *   - vars: extra vars to fire the event with
   *   - type: site or subsite
   *   - error: an error key token to use in case of error or NULL to
   *     not display a message.
   * 
   * @param array $defaults
   *   Default values for all steps. Can specify anything except the 
   *   "event" key.
   * 
   * @return boolean
   *   TRUE if all events executed, otherwise FALSE.
   */
  protected function executeAllSteps(array $steps, $defaults = array()) {
    $defaults += array(
      'optional' => FALSE,
      'failContinue' => FALSE,
      'die' => 1,
      'error' => STRING_ERROR_STEP_GENERIC,
      'type' => COMMAND_STEP_SITE,
      'vars' => array(),
    );
    $success = TRUE;
    foreach ($steps as $step) {
      $step += $defaults;
      
      switch ($step['type']) {
        case COMMAND_STEP_ALL_INSTALLED_SUBSITES:
          $success = $this->executeAllSubSiteCommandStep(
              $step['event'],
              !empty($step['optional']),
              empty($step['die']) ? 0 : $step['die'],
              isset($step['error']) ? $step['error'] : NULL,
              $step['vars'],
              $step['failContinue'],
              TRUE
          ) && $success;
          break;
        case COMMAND_STEP_ALL_SUBSITES:
          $success = $this->executeAllSubSiteCommandStep(
              $step['event'],
              !empty($step['optional']),
              empty($step['die']) ? 0 : $step['die'],
              isset($step['error']) ? $step['error'] : NULL,
              $step['vars'],
              $step['failContinue']
          ) && $success;
          break;
        case COMMAND_STEP_SUBSITE:
          $success = $this->executeSubSiteCommandStep(
              $step['event'],
              !empty($step['optional']),
              empty($step['die']) ? 0 : $step['die'],
              isset($step['error']) ? $step['error'] : NULL,
              $step['vars']
          ) && $success;
          break;
        case COMMAND_STEP_SITE:
        default:
          $success = $this->executeSiteCommandStep(
              $step['event'],
              !empty($step['optional']),
              empty($step['die']) ? 0 : $step['die'],
              isset($step['error']) ? $step['error'] : NULL,
              $step['vars'],
              $step['failContinue']
          ) && $success;
          break;
      }
    }
    return $success;
  }
  
  /**
   * Executes a command step for a site.
   * 
   * @param string $event
   *   Identifying string for the event.
   * @param boolean $optional
   *   Whether or not the event is optional.
   * @param int $die
   *   The error code to die with. If set to 0, will not die.
   * @param string $error
   *   The error lookup string to display on error. Set to NULL to not display
   *   a message.
   * @param array $vars
   *   An array of extra variables.
   * @param boolean $failContinue
   *   Whether or not to continue execution on failure.
   * 
   * @return boolean
   *   TRUE if successful (or optional and not handled), FALSE if die is empty
   *   otherwise.
   */
  protected function executeSiteCommandStep($event, $optional = FALSE, $die = 1, $error = NULL, $vars = array(), $failContinue = FALSE) {
    $context = array(
      'entity' => $this->getSite(),
      'name' => $event,
      'optional' => $optional,
      'variables' => $vars,
      'error' => $error,
      'continue' => !empty($die),
      'code' => empty($die) ? 1 : $die,
      'failContinue' => !empty($failContinue),
    );
    return DrupalSiteEvent::fireSiteEvent($this->strings(), $this->out(), $this->events(), $context);
  }
    
  /**
   * Executes a command step for a subsite.
   * 
   * @param string $event
   *   Identifying string for the event.
   * @param boolean $optional
   *   Whether or not the event is optional.
   * @param int $die
   *   The error code to die with. If set to 0, will not die.
   * @param string $error
   *   The error lookup string to display on error. Set to NULL to not display
   *   a message.
   * @param array $vars
   *   An array of extra variables.
   * @param boolean $failContinue
   *   Whether or not to continue execution on failure.
   * 
   * @return boolean
   *   TRUE if successful (or optional and not handled), FALSE if die is empty
   *   otherwise.
   */
  protected function executeSubSiteCommandStep($event, $optional = FALSE, $die = 1, $error = NULL, $vars = array(), $failContinue = FALSE) {
    $context = array(
      'entity' => $this->getSubSite(),
      'name' => $event,
      'optional' => $optional,
      'variables' => $vars,
      'error' => $error,
      'continue' => !empty($die),
      'code' => empty($die) ? 1 : $die,
      'failContinue' => !empty($failContinue),
    );
    return DrupalSiteEvent::fireSiteEvent($this->strings(), $this->out(), $this->events(), $context);
  }
  
  /**
   * Executes a command step for a subsite.
   * 
   * @param string $event
   *   Identifying string for the event.
   * @param boolean $optional
   *   Whether or not the event is optional.
   * @param int $die
   *   The error code to die with. If set to 0, will not die.
   * @param string $error
   *   The error lookup string to display on error. Set to NULL to not display
   *   a message.
   * @param array $vars
   *   An array of extra variables.
   * @param boolean $failContinue
   *   Whether or not to continue execution on failure.
   * @param boolean $installedOnly
   *   Limit actions to subsites that have been installed.
   * 
   * @return boolean
   *   TRUE if successful (or optional and not handled), FALSE if die is empty
   *   otherwise.
   */
  protected function executeAllSubSiteCommandStep($event, $optional = FALSE, $die = 1, $error = NULL, $vars = array(), $failContinue = FALSE, $installedOnly = FALSE) {
    $context = array(
      'entity' => NULL,
      'name' => $event,
      'optional' => $optional,
      'variables' => $vars,
      'error' => $error,
      'continue' => !empty($die),
      'code' => empty($die) ? 1 : $die,
      'failContinue' => !empty($failContinue),
    );
    $success = TRUE;
    $site = $this->getSite();
    foreach ($site->getSubSites() as $id) {
      $context['entity'] = $site->getSubSite($id);
      if ($installedOnly && (extra_empty($context['entity']->getSetting(SITE_IS_INSTALLED)))) {
        continue;
      }
      $success = DrupalSiteEvent::fireSiteEvent($this->strings(), $this->out(), $this->events(), $context) && $success;
    }
    return $success;
  }
  
  /**
   * Saves the site configuration, with error message and optional auto-death.
   * 
   * @param boolean $die
   *   Set to FALSE to not die but return FALSE instead.
   * 
   * @return boolean
   *   Whether or not the site configuration was saved.
   */
  protected function saveSiteConfiguration($die = TRUE) {
    $site = $this->getSite();
    return $this->saveEntityConfiguration($site, $die);
  }
  
  /**
   * Saves the subsite configuration, with error message and optional auto-death.
   * 
   * @param boolean $die
   *   Set to FALSE to not die but return FALSE instead.
   * 
   * @return boolean
   *   Whether or not the site configuration was saved.
   */
  protected function saveSubSiteConfiguration($die = TRUE) {
    $subsite = $this->getSubSite();
    $site = $subsite->getParentSite();
    return $this->saveEntityConfiguration($site, $die) && 
        $this->saveEntityConfiguration($subsite, $die);
  }
  
  /**
   * Saves the subsite configuration, with error message and optional auto-death.
   * 
   * @param boolean $die
   *   Set to FALSE to not die but return FALSE instead.
   * 
   * @return boolean
   *   Whether or not the site configuration was saved.
   */
  protected function saveAllSubSiteConfiguration($die = TRUE) {
    $site = $this->getSite();
    $success = TRUE;
    foreach ($site->getSubSites() as $id) {
      $subsite = $site->getSubSite($id);
      $success = $this->saveEntityConfiguration($subsite, $die) && $success;
    }
    return $this->saveEntityConfiguration($site, $die) && $success;
  }
  
  /**
   * Saves the entity configuration, with error message and optional auto-death.
   * 
   * @param GenericDrupalEntity $entity
   *   The Drupal entity to save.
   * @param boolean $die
   *   Set to FALSE to not die but return FALSE instead.
   * 
   * @return boolean
   *   Whether or not the site configuration was saved.
   */
  private function saveEntityConfiguration(GenericDrupalEntity $entity, $die = TRUE) {
    $this->out()->message($this->strings()->getString(STRING_WORKING_SAVE_CONFIG, array(
      '!uuid' => $entity->uuid(),
    )));
    if (!$entity->saveConfiguration()) {
      $this->error(STRING_COULD_NOT_SAVE_SITE, array(
        '!uuid' => $entity->uuid(),
      ));
      if ($die) {
        exit(1);
      }
      return FALSE;
    }
    return TRUE;
  }
  
}