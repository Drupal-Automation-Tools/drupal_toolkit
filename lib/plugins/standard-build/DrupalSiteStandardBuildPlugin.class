<?php
/**
 * @file Defines the DrupalSiteStandardBuildPlugin class.
 */

/**
 * Config key for the git repository server name.
 * 
 * This should include everything up until the git repo name.
 * 
 * @ingroup config
 */
define('CONFIG_GIT_REPO_ROOT', 'git-repository-root');

/**
 * Config key for the git repository that contains a drush make file.
 * 
 * This should include everything after CONFIG_GIT_REPO_ROOT.
 * 
 * @ingroup config
 */
define('CONFIG_DRUSH_MAKE_REPO', 'drush-make-repository');

/**
 * Config key for the name of the drush make file within CONFIG_DRUSH_MAKE_REPO.
 * 
 * @ingroup config
 */
define('CONFIG_DRUSH_MAKE_FILE', 'drush-make-file');

/**
 * Config key for an array of options to pass to the drush make command.
 * 
 * Any flag option can be specified, without its leading two hyphens (eg 
 * working-copy, no-gitinfofile, etc).
 * 
 * @ingroup config
 */
define('CONFIG_DRUSH_MAKE_OPTIONS', 'drush-make-options');

/**
 * Config key for the default branch to use if one is not passed via
 * OPTION_BRANCH.
 * 
 * Defaults to master.
 * 
 * @ingroup config
 */
define('CONFIG_DEFAULT_BRANCH', 'default-branch');

/**
 * Config key for a list of acceptable branch names. Use this to prevent
 * accidently using certain branches.
 * 
 * Defaults to no restrictions.
 * 
 * @ingroup config
 */
define('CONFIG_BRANCH_WHITELIST', 'branch-whitelist');

/**
 * Option name to specify the branch name.
 * 
 * @ingroup args
 */
define('OPTION_BRANCH', 'branch');

/**
 * String token for the error message if no branch is specified.
 * 
 * @ingroup strings
 */
define('STRING_SITE_NO_BRANCH', 'standard_build.error.no-branch');

/**
 * String token for the error message if this plugin is not paired with one
 * that supplies SITE_CODEBASE_DIR.
 * 
 * @ingroup strings
 */
define('STRING_SITE_INVALID_CODEBASE', 'standard_build.error.no-codebase');

/**
 * String token for the error message if the clone fails.
 * 
 * @ingroup strings
 */
define('STRING_SITE_NO_CLONE', 'standard_build.error.clone-failure');

/**
 * String token for the error message if the make fails.
 * 
 * @ingroup strings
 */
define('STRING_SITE_NO_MAKE', 'standard_build.error.make-failure');

/**
 * String token for if the process to create a current symlink fails.
 * 
 * @ingroup strings
 */
define('STRING_SITE_NO_CURRENT', 'standard_build.error.current-symlink-failure');

/**
 * Site setting that contains the name of the branch cloned in this step.
 * 
 * @ingroup site_settings
 */
define('SITE_SETTING_CLONED_BRANCH', 'cloned-branch');

/**
 * Site setting that contains the path to the current codebase that we just
 * made.
 * 
 * @ingroup site_settings
 */
define('SITE_SETTING_CURRENT_BUILD', 'build-current-codebase-dir');

/**
 * Fired after this plugin is done so other modules can extend the build.
 * 
 * @ingroup events
 */
define('EVENT_CONTINUE_STANDARD_BUILD', 'standard-build-continue');

/**
 * String token for if a build directory could not be deleted.
 * 
 * @ingroup strings
 */
define('STRING_ERROR_UNABLE_TO_DELETE_CODEBASE', 'standard_build.error.delete-codebase');

/**
 * Config key for an array of files to remove from each build.
 * 
 * @ingroup config
 */
define('CONFIG_REMOVE_BUILD_FILES', 'remove-build-files');

/**
 * String token for when a codebase that was reverted from is being saved.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_SAVE_REVERTED_CODE', 'standard_build.working.save-reverted');

/**
 * String token for when a reverted codebase was saved successfully.
 * 
 * @strings
 */
define('STRING_SUCCESS_BUILD_SAVE_REVERTED_CODE', 'standard_build.success.save-reverted');

/**
 * String token for when a reverted codebase fails to save properly.
 * 
 * @strings
 */
define('STRING_FAILURE_BUILD_SAVE_REVERTED_CODE', 'standard_build.failure.save-reverted');

/**
 * String token for when extra files are successfully removed.
 * 
 * @strings
 */
define('STRING_SUCCESS_BUILD_REMOVE_EXTRAS', 'standard_build.success.remove-extras');

/**
 * String token for when the toolkit failed to remove extra files from the build.
 * 
 * @strings
 */
define('STRING_FAILURE_BUILD_REMOVE_EXTRAS', 'standard_build.failure.remove-extras');

/**
 * String token for when extra files are about to be removed from the build.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_REMOVE_EXTRAS', 'standard_build.working.remove-extras');

/**
 * String token for when a codebase is about to be deleted.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_DELETE_CODEBASE', 'standard_build.working.delete-codebase');

/**
 * String token for when a codebase was successfully deleted.
 * 
 * @strings
 */
define('STRING_SUCCESS_BUILD_DELETE_CODEBASE', 'standard_build.success.delete-codebase');

/**
 * String token for when the current symlink is about to be updated.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_CURRENT_SYMLINK', 'standard_build.working.symlink-current');

/**
 * String token for when the current symlink was successfully updated.
 * 
 * @strings
 */
define('STRING_SUCCESS_BUILD_CURRENT_SYMLINK', 'standard_build.success.symlink-current');

/**
 * String token for when certain site variables are about to be reverted.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_REVERT_SITE_VARS', 'standard_build.working.revert-site-vars');

/**
 * String token for when the site variables were fully reverted.
 * 
 * @strings
 */
define('STRING_SUCCESS_BUILD_REVERT_SITE_VARS', 'standard_build.success.revert-site-vars');

/**
 * String token for when a new codebase is about to be constructed.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_CONSTRUCT_CODEBASE', 'standard_build.working.construct-codebase');

/**
 * String token for when the make repo is about to be cloned.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_GIT_CLONE', 'standard_build.working.git-clone');

/**
 * String token for when the drush make command is about to be run.
 * 
 * @strings
 */
define('STRING_WORKING_BUILD_DRUSH_MAKE', 'standard_build.working.drush-make');

/**
 * String token for when a new codebase is completed successfully.
 * 
 * @strings
 */
define('STRING_SUCCESS_BUILD_CONSTRUCT_CODEBASE', 'standard_build.success.construct-codebase');


/**
 * Responsible for building a new codebase on demand.
 * 
 * For this standard plugin, this includes:
 * - Clone a git repo into the codebases directory
 * - Run a drush make on a make file from that git repo
 * - Update a link to the current codebase
 */
class DrupalSiteStandardBuildPlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $this->events()->registerListener(array(
      EVENT_SITE_BUILD_CODEBASE,
      EVENT_UPDATE_CODEBASE,
      EVENT_DELETE_BUILD,
      EVENT_UPDATE_PREPARE_FOR_UPDATE,
      EVENT_ROLLBACK_PHASE1,
      EVENT_ROLLBACK_PHASE3,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_GIT_REPO_ROOT => '',
      CONFIG_DRUSH_MAKE_REPO => '',
      CONFIG_DRUSH_MAKE_FILE => '',
      CONFIG_DRUSH_MAKE_OPTIONS => array(
        'prepare-install'
      ),
      CONFIG_DEFAULT_BRANCH => 'master',
      CONFIG_BRANCH_WHITELIST => array(),
      CONFIG_REMOVE_BUILD_FILES => array(),
    ));
  }
  
  public function requiredPlugins() {
    return array('DrupalSitePlugin');
  }
  
  public function captureEvent(DtkEvent &$context, $type) {
    switch ($type) {
      case EVENT_UPDATE_CODEBASE:
      case EVENT_SITE_BUILD_CODEBASE:
        if ($context->checkExecution()) {
          $context->setResult($this->buildSite($context->getSite(), $context->getVariable('buildID')));
        }
        break;
      case EVENT_UPDATE_PREPARE_FOR_UPDATE:
      case EVENT_ROLLBACK_PHASE3:
        if ($context->checkExecution()) {
          $context->setResult($this->updateCurrentLink($context->getSite()));
        }
        break;
      case EVENT_DELETE_BUILD:
        if ($context->checkExecution()) {
          $context->setResult($this->deleteBuild($context->getSite(), $context->getVariable('buildID')));
        }
        break;
      case EVENT_ROLLBACK_PHASE1:
        if ($context->checkExecution()) {
          $context->setResult($this->refreshSiteVariables($context->getSite(), $context->getVariable('revertBuild')));
        }
        break;
      case EVENT_ROLLBACK_CLEAN:
        if ($context->checkExecution()) {
          $context->setResult($this->saveRevertedCodebase($context->getSite(), $context->getVariable('currentBuild')));
        }
        break;
    }
  }
  
  /**
   * Preserves the codebase that is being rolled back.
   * 
   * @param DrupalSite $site
   *   The site to preserve.
   * @param string $revertedID
   *   The ID of the codebase to save.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function saveRevertedCodebase(DrupalSite $site, $revertedID) {
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR, NULL, TRUE);
    if (empty($cbDir)) { return FALSE; }
    $this->working(STRING_WORKING_BUILD_SAVE_REVERTED_CODE);
    $revertedBase = assemble_path($site->getBuildFolder(), $cbDir, $revertedID);
    $target = assemble_path($site->getBuildFolder(), 'reverted', $revertedID, 'code');
    $ret = copy_all($revertedBase, $target);
    if ($ret) {
      $this->success(STRING_SUCCESS_BUILD_SAVE_REVERTED_CODE);
    }
    else {
      $this->failure(STRING_FAILURE_BUILD_SAVE_REVERTED_CODE);
    }
    return $ret;
  }
  
  /**
   * Removes all extra files from the build directory.
   * 
   * @param string $buildDirectory
   *   Path to a codebase.
   * 
   * @return boolean
   *   TRUE, if the files were deleted, otherwise FALSE.
   */
  private function removeExtraFiles($buildDirectory) {
    if (!is_dir($buildDirectory)) { return TRUE; }
    $extraFiles = $this->config()->getConfig(CONFIG_REMOVE_BUILD_FILES);
    if (empty($extraFiles)) { return TRUE; }
    $this->working(STRING_WORKING_BUILD_REMOVE_EXTRAS, array(
      '!files' => implode(', ', $extraFiles),
    ));
    $ret = TRUE;
    foreach ($extraFiles as $file) {
      $path = assemble_path($buildDirectory, $file);
      if (file_exists($path)) {
        if (is_dir($path)) {
          remove_directory($path);
        }
        else {
          unlink($path);
        }
        if (file_exists($path)) {
          $ret = FALSE;
        }
      }
    }
    if ($ret) {
      $this->success(STRING_SUCCESS_BUILD_REMOVE_EXTRAS);
    }
    else {
      $this->failure(STRING_FAILURE_BUILD_REMOVE_EXTRAS);
    }
    return $ret;
  }
  
  /**
   * Deletes a codebase from a drupal site.
   * 
   * @param DrupalSite $site
   *   The site to delete from.
   * @param string $buildID
   *   The build ID to delete.
   * 
   * @return boolean
   *   TRUE if the build was deleted, otherwise FALSE.
   */
  private function deleteBuild(DrupalSite $site, $buildID) {
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR, NULL, TRUE);
    if (empty($cbDir)) { return FALSE; }
    $this->working(STRING_WORKING_BUILD_DELETE_CODEBASE, array(
      '!buildID' => $buildID,
    ));
    $deleteCodebase = assemble_path($site->getBuildFolder(), $cbDir, $buildID);
    if (is_dir($deleteCodebase)) {
      remove_directory($deleteCodebase);
    }
    if (is_dir($deleteCodebase)) {
      $this->error(STRING_ERROR_UNABLE_TO_DELETE_CODEBASE);
      return FALSE;
    }
    $this->success(STRING_SUCCESS_BUILD_DELETE_CODEBASE);
    return TRUE;
  }
  
  /**
   * Updates the current link to point to the most current build.
   * 
   * @param DrupalSite $site
   *   The site to update.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function updateCurrentLink(DrupalSite $site) {
    $this->working(STRING_WORKING_BUILD_CURRENT_SYMLINK);
    $latestCodebase = $site->getSetting(SITE_SETTING_CURRENT_BUILD, NULL, TRUE);
    if (empty($latestCodebase)) { return FALSE; }
    $currentLink = assemble_path($site->getBuildFolder(), 'current');
    if (is_link($currentLink)) {
      unlink($currentLink);
    }
    if (!symlink($latestCodebase, $currentLink)) {
      $this->error(STRING_SITE_NO_CURRENT);
      return FALSE;
    }
    $this->success(STRING_SUCCESS_BUILD_CURRENT_SYMLINK);
    return TRUE;
  }
  
  /**
   * Refreshes the site variables.
   * 
   * @param DrupalSite $site
   *   The site being rolled back.
   * @param string $oldBuildID
   *   The old build ID.
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function refreshSiteVariables(DrupalSite $site, $oldBuildID) {
    $this->working(STRING_WORKING_BUILD_REVERT_SITE_VARS);
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR, NULL, TRUE);
    if (empty($cbDir)) { return FALSE; }
    $buildDir = assemble_path($site->getBuildFolder(), $cbDir, $oldBuildID);
    $site->setSetting(SITE_SETTING_CURRENT_BUILD, $buildDir);
    $this->success(STRING_SUCCESS_BUILD_REVERT_SITE_VARS);
    return TRUE;
  }
  
  /**
   * Responsible for building the site's codebase.
   * 
   * @param DrupalSite $site
   *   The site to build.
   * @param string $buildID
   *   The build ID.
   * 
   * @return boolean
   *   TRUE if the build was successful, otherwise FALSE.
   */
  private function buildSite(DrupalSite $site, $buildID, $update = FALSE) {
    $this->working(STRING_WORKING_BUILD_CONSTRUCT_CODEBASE);
    $config = $this->getConfig(array(
      CONFIG_GIT_REPO_ROOT,
      CONFIG_DRUSH_MAKE_REPO,
      CONFIG_DRUSH_MAKE_FILE,
    ), array(
      CONFIG_DRUSH_MAKE_OPTIONS,
    ));
    $branch = $this->getBranch($site);
    if (empty($branch)) { 
      $this->error(STRING_SITE_NO_BRANCH);
      return FALSE;
    }
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR);
    if (empty($cbDir)) { return FALSE; }
    $newCodebase = assemble_path($site->getBuildFolder(), $cbDir, $buildID);
    if (!is_writable(dirname($newCodebase))) {
      $this->error(STRING_SITE_INVALID_CODEBASE);
      return FALSE;
    }
    $this->working(STRING_WORKING_BUILD_GIT_CLONE);
    if (!git_clone($config[CONFIG_GIT_REPO_ROOT], $config[CONFIG_DRUSH_MAKE_REPO], $newCodebase, $branch)) {
      $this->error(STRING_SITE_NO_CLONE);
      return FALSE;
    }
    $site->setSetting(SITE_SETTING_CLONED_BRANCH, $branch);
    $this->working(STRING_WORKING_BUILD_DRUSH_MAKE);
    if (!drush_make(assemble_path($newCodebase, $config[CONFIG_DRUSH_MAKE_FILE]), $config[CONFIG_DRUSH_MAKE_OPTIONS])) {
      $this->error(STRING_SITE_NO_MAKE);
      return FALSE;
    }
    $this->removeExtraFiles($newCodebase);
    $site->setSetting(SITE_SETTING_CURRENT_BUILD, $newCodebase);
    if (!$update) {
      if (!$this->updateCurrentLink($site)) {
        return FALSE;
      }
    }
    $event = new DrupalSiteEvent($site, TRUE);
    
    $this->events()->fireEvent(EVENT_CONTINUE_STANDARD_BUILD, $event);
    
    if ($event->success()) {
      $this->success(STRING_SUCCESS_BUILD_CONSTRUCT_CODEBASE);
    }
    
    return $event->success();
  }
  
  /**
   * Retrieves the current branch.
   * 
   * @return string
   *   The branch name or NULL if none was found.
   */
  private function getBranch(DrupalSite $site) {
    $branch = $this->args()->getOption(OPTION_BRANCH);
    if (empty($branch)) {
      $branch = $site->getSetting(SITE_SETTING_CLONED_BRANCH);
    }
    if (empty($branch)) {
      $branch = $this->config()->getConfig(CONFIG_DEFAULT_BRANCH);
    }
    if (empty($branch)) {
      return NULL;
    }
    $branchWhitelist = $this->config()->getConfig(CONFIG_BRANCH_WHITELIST);
    if (!empty($branchWhitelist) && is_array($branchWhitelist)) {
      if (!in_array($branch, $branchWhitelist)) {
        return NULL;
      }
    }
    return $branch;
  }
  
}
