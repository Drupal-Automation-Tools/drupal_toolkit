<?php
/**
 * @file Defines the DrupalSiteStandardBuildPlugin class.
 */

/**
 * Responsible for building a new codebase on demand.
 * 
 * For this standard plugin, this includes:
 * - Clone a git repo into the codebases directory
 * - Run a drush make on a make file from that git repo
 * - Update a link to the current codebase
 * 
 * @ingroup plugins
 */
class DrupalSiteStandardBuildPlugin extends GenericPlugin implements EventListener {
  
  /**
   * The name of the symlink to the current build.
   * 
   * @var string
   */
  private static $currentSymlinkName = 'current';
  
  public function initialize() {
    $this->events()->registerListener(array(
      EVENT_SITE_BUILD_CODEBASE,
      EVENT_UPDATE_CODEBASE,
      EVENT_REMOVE_ALL,
      EVENT_UPDATE_PREPARE_FOR_UPDATE,
      EVENT_ROLLBACK_PHASE1,
      EVENT_ROLLBACK_PHASE3,
      EVENT_GET_INFO,
      EVENT_ALTER_HELP_INSTRUCTIONS,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_GIT_REPO_ROOT => '',
      CONFIG_DRUSH_MAKE_REPO => '',
      CONFIG_DRUSH_MAKE_FILE => '',
      CONFIG_DRUSH_MAKE_OPTIONS => array(
        'prepare-install'
      ),
      CONFIG_DEFAULT_BRANCH => 'master',
      CONFIG_BRANCH_WHITELIST => array(),
      CONFIG_REMOVE_BUILD_FILES => array(),
    ));
  }
  
  public function captureEvent(DtkEvent &$context, $type) {
    switch ($type) {
      case EVENT_ALTER_HELP_INSTRUCTIONS:
        $context->defineOptions(array('site-build', 'subsite-build', 'site-update'), OPTION_BRANCH, $this->str(STRING_HELP_OPTION_BRANCH_DESC));
        break;
      case EVENT_GET_INFO:
        $entity = $context->getEntity();
        if ($entity instanceof DrupalSubSite) {
          $entity = $entity->getParentSite();
        }
        $context->appendInfo($this->str(STRING_INFO_BUILD), $entity->getSetting(SITE_BUILD_DIR));
        $context->appendInfo($this->str(STRING_INFO_BRANCH), $entity->getSetting(SITE_SETTING_CLONED_BRANCH));
        break;
      case EVENT_UPDATE_CODEBASE:
      case EVENT_SITE_BUILD_CODEBASE:
        if ($context->checkExecution()) {
          $context->setResult($this->buildSite($context->getSite(), $context->getVariable('buildID'), $type === EVENT_UPDATE_CODEBASE));
        }
        break;
      case EVENT_UPDATE_PREPARE_FOR_UPDATE:
      case EVENT_ROLLBACK_PHASE3:
        if ($context->checkExecution()) {
          $context->setResult($this->updateCurrentLink($context->getSite()));
        }
        break;
      case EVENT_DELETE_BUILD:
        if ($context->checkExecution()) {
          $context->setResult($this->deleteBuild($context->getSite(), $context->getVariable('buildID')));
        }
        break;
      case EVENT_ROLLBACK_PHASE1:
        if ($context->checkExecution()) {
          $context->setResult($this->refreshSiteVariables($context->getSite(), $context->getVariable('revertBuild')));
        }
        break;
      case EVENT_ROLLBACK_CLEAN:
        if ($context->checkExecution()) {
          $context->setResult($this->saveRevertedCodebase($context->getSite(), $context->getVariable('currentBuild')));
        }
        break;
    }
  }
  
  /**
   * Preserves the codebase that is being rolled back.
   * 
   * @param DrupalSite $site
   *   The site to preserve.
   * @param string $revertedID
   *   The ID of the codebase to save.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function saveRevertedCodebase(DrupalSite $site, $revertedID) {
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR, NULL, TRUE);
    if (empty($cbDir)) { return FALSE; }
    $this->working(STRING_WORKING_BUILD_SAVE_REVERTED_CODE);
    $revertedBase = assemble_path($site->getBuildFolder(), $cbDir, $revertedID);
    $target = assemble_path($site->getBuildFolder(), 'reverted', $revertedID, 'code');
    $ret = copy_all($revertedBase, $target);
    if ($ret) {
      $this->success(STRING_SUCCESS_BUILD_SAVE_REVERTED_CODE);
    }
    else {
      $this->failure(STRING_FAILURE_BUILD_SAVE_REVERTED_CODE);
    }
    return $ret;
  }
  
  /**
   * Removes all extra files from the build directory.
   * 
   * @param string $buildDirectory
   *   Path to a codebase.
   * 
   * @return boolean
   *   TRUE, if the files were deleted, otherwise FALSE.
   */
  private function removeExtraFiles($buildDirectory) {
    if (!is_dir($buildDirectory)) { return TRUE; }
    $extraFiles = $this->config()->getConfig(CONFIG_REMOVE_BUILD_FILES);
    if (empty($extraFiles)) { return TRUE; }
    $this->working(STRING_WORKING_BUILD_REMOVE_EXTRAS, array(
      '!files' => implode(', ', $extraFiles),
    ));
    $ret = TRUE;
    foreach ($extraFiles as $file) {
      $path = assemble_path($buildDirectory, $file);
      if (file_exists($path)) {
        if (is_dir($path)) {
          remove_directory($path);
        }
        else {
          unlink($path);
        }
        if (file_exists($path)) {
          $ret = FALSE;
        }
      }
    }
    if ($ret) {
      $this->success(STRING_SUCCESS_BUILD_REMOVE_EXTRAS);
    }
    else {
      $this->failure(STRING_FAILURE_BUILD_REMOVE_EXTRAS);
    }
    return $ret;
  }
  
  /**
   * Deletes a codebase from a drupal site.
   * 
   * @param DrupalSite $site
   *   The site to delete from.
   * @param string $buildID
   *   The build ID to delete.
   * 
   * @return boolean
   *   TRUE if the build was deleted, otherwise FALSE.
   */
  private function deleteBuild(DrupalSite $site, $buildID) {
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR, NULL, TRUE);
    if (empty($cbDir)) { return FALSE; }
    $this->working(STRING_WORKING_BUILD_DELETE_CODEBASE, array(
      '!buildID' => $buildID,
    ));
    $deleteCodebase = assemble_path($site->getBuildFolder(), $cbDir, $buildID);
    if (is_dir($deleteCodebase)) {
      remove_directory($deleteCodebase);
    }
    if (is_dir($deleteCodebase)) {
      $this->error(STRING_ERROR_UNABLE_TO_DELETE_CODEBASE);
      return FALSE;
    }
    $this->success(STRING_SUCCESS_BUILD_DELETE_CODEBASE);
    return TRUE;
  }
  
  /**
   * Updates the current link to point to the most current build.
   * 
   * @param DrupalSite $site
   *   The site to update.
   * 
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function updateCurrentLink(DrupalSite $site) {
    $this->working(STRING_WORKING_BUILD_CURRENT_SYMLINK);
    $latestCodebase = $site->getSetting(SITE_SETTING_CURRENT_BUILD, NULL, TRUE);
    if (empty($latestCodebase)) { return FALSE; }
    $currentLink = assemble_path($site->getBuildFolder(), self::$currentSymlinkName);
    if (is_link($currentLink)) {
      unlink($currentLink);
    }
    if (!symlink($latestCodebase, $currentLink)) {
      $this->error(STRING_SITE_NO_CURRENT);
      return FALSE;
    }
    $site->setSetting(SITE_CURRENT_SYMLINK, $currentLink);
    // we save the configuration here because an out-of-date symlink causes
    // many problems (eg if the update fails/stalls after this point). Saving
    // the new build ID at this point prevents some of these problems from
    // occuring. 
    $site->saveConfiguration();
    $this->success(STRING_SUCCESS_BUILD_CURRENT_SYMLINK);
    return TRUE;
  }
  
  /**
   * Refreshes the site variables.
   * 
   * @param DrupalSite $site
   *   The site being rolled back.
   * @param string $oldBuildID
   *   The old build ID.
   * @return boolean
   *   TRUE if successful, otherwise FALSE.
   */
  private function refreshSiteVariables(DrupalSite $site, $oldBuildID) {
    $this->working(STRING_WORKING_BUILD_REVERT_SITE_VARS);
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR, NULL, TRUE);
    if (empty($cbDir)) { return FALSE; }
    $buildDir = assemble_path($site->getBuildFolder(), $cbDir, $oldBuildID);
    $site->setSetting(SITE_SETTING_CURRENT_BUILD, $buildDir);
    $this->success(STRING_SUCCESS_BUILD_REVERT_SITE_VARS);
    return TRUE;
  }
  
  /**
   * Responsible for building the site's codebase.
   * 
   * @param DrupalSite $site
   *   The site to build.
   * @param string $buildID
   *   The build ID.
   * 
   * @return boolean
   *   TRUE if the build was successful, otherwise FALSE.
   */
  private function buildSite(DrupalSite $site, $buildID, $update = FALSE) {
    $this->working(STRING_WORKING_BUILD_CONSTRUCT_CODEBASE);
    $config = $this->getConfig(array(
      CONFIG_GIT_REPO_ROOT,
      CONFIG_DRUSH_MAKE_REPO,
      CONFIG_DRUSH_MAKE_FILE,
    ), array(
      CONFIG_DRUSH_MAKE_OPTIONS,
    ));
    $branch = $this->getBranch($site);
    if (empty($branch)) { 
      $this->error(STRING_SITE_NO_BRANCH);
      return FALSE;
    }
    $cbDir = $site->getSetting(SITE_CODEBASE_DIR);
    if (empty($cbDir)) { return FALSE; }
    $newCodebase = assemble_path($site->getBuildFolder(), $cbDir, $buildID);
    if (!is_writable(dirname($newCodebase))) {
      $this->error(STRING_SITE_INVALID_CODEBASE);
      return FALSE;
    }
    $this->working(STRING_WORKING_BUILD_GIT_CLONE);
    if (!git_clone($config[CONFIG_GIT_REPO_ROOT], $config[CONFIG_DRUSH_MAKE_REPO], $newCodebase, $branch)) {
      $this->error(STRING_SITE_NO_CLONE);
      return FALSE;
    }
    $site->setSetting(SITE_SETTING_CLONED_BRANCH, $branch);
    $this->working(STRING_WORKING_BUILD_DRUSH_MAKE);
    if (!drush_make(assemble_path($newCodebase, $config[CONFIG_DRUSH_MAKE_FILE]), $config[CONFIG_DRUSH_MAKE_OPTIONS])) {
      $this->error(STRING_SITE_NO_MAKE);
      return FALSE;
    }
    $this->removeExtraFiles($newCodebase);
    $site->setSetting(SITE_SETTING_CURRENT_BUILD, $newCodebase);
    if (!$update) {
      if (!$this->updateCurrentLink($site)) {
        return FALSE;
      }
    }
    $event = new DrupalSiteEvent($site, TRUE);
    
    $this->events()->fireEvent(EVENT_CONTINUE_STANDARD_BUILD, $event);
    
    if ($event->success()) {
      $this->success(STRING_SUCCESS_BUILD_CONSTRUCT_CODEBASE);
    }
    
    return $event->success();
  }
  
  /**
   * Retrieves the current branch.
   * 
   * @return string
   *   The branch name or NULL if none was found.
   */
  private function getBranch(DrupalSite $site) {
    $branch = $this->args()->getOption(OPTION_BRANCH);
    if (empty($branch)) {
      $branch = $site->getSetting(SITE_SETTING_CLONED_BRANCH);
    }
    if (empty($branch)) {
      $branch = $this->config()->getConfig(CONFIG_DEFAULT_BRANCH);
    }
    if (empty($branch)) {
      return NULL;
    }
    $branchWhitelist = $this->config()->getConfig(CONFIG_BRANCH_WHITELIST);
    if (!empty($branchWhitelist) && is_array($branchWhitelist)) {
      if (!in_array($branch, $branchWhitelist)) {
        return NULL;
      }
    }
    return $branch;
  }
  
}
