<?php
/**
 * @file Defines the HttpConfigurationPlugin class.
 * 
 * @defgroup http_types "HTTP Server Types"
 * The different HTTP server types.
 */

/**
 * Server setting to override the HTTP configuration directory from the 
 * default for the server type.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_HTTP_CONFIG_DIR', 'http-config-dir');

/**
 * Server setting to override the location of the HTTP configuration template.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_HTTP_CONFIG_TEMPLATE', 'http-config-template');

/**
 * Server setting to override the location of the HTTP file template.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_HTTP_FILE_TEMPLATE', 'http-file-template');

/**
 * Fired when an HTTP server needs to be cast based on its type.
 * 
 * @ingroup events
 */
define('EVENT_CAST_HTTP_SERVER', 'cast-http-server');

/**
 * Config key for whether or not we should use the local server as an HTTP
 * server.
 * 
 * @ingroup config
 */
define('CONFIG_HTTP_USE_LOCAL', 'http-local');

/**
 * Config key for the default server type.
 * 
 * @ingroup config
 * @see @ref http_types "HTTP Server Types"
 */
define('CONFIG_HTTP_DEFAULT_SERVER_TYPE', 'http-server-type');

/**
 * Config key for whether or not the configuration should be treated as static.
 * If set to TRUE, no HTTP server will have its configuration updated on
 * update.
 * 
 * @ingroup config
 */
define('CONFIG_HTTP_STATIC_CONFIG', 'http-static-config');

/**
 * Config key for the default config template file.
 * 
 * @ingroup config
 * @see DrupalSite::replaceTokens()
 */
define('CONFIG_HTTP_DEFAULT_CONFIG_TEMPLATE', 'http-config-template');

/**
 * Config key for the default config filename tempalte.
 * 
 * @ingroup config
 * @see DrupalSite::replaceTokens()
 */
define('CONFIG_HTTP_DEFAULT_FILENAME_TEMPLATE', 'http-config-filename-template');

/**
 * Server type for HTTP servers.
 * 
 * @ingroup server_types
 */
define('SERVER_TYPE_HTTP', 'http');

/**
 * Set to TRUE to prevent the local server from being used as an HTTP server.
 * 
 * @ingroup config
 */
define('CONFIG_DISABLE_LOCAL_HTTP', 'si-disable-local-http');

/**
 * HTTP server type for apache2 servers.
 * 
 * @ingroup http_types
 */
define('HTTP_TYPE_APACHE2', 'apache2');

/**
 * HTTP server type for nginx servers.
 * 
 * @ingroup http_types
 */
define('HTTP_TYPE_NGINX', 'nginx');

/**
 * HTTP server type for httpd servers.
 * 
 * @ingroup http_types
 */
define('HTTP_TYPE_HTTPD', 'httpd');

/**
 * Server setting to override the default HTTP type.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_HTTP_TYPE', 'http-type');

/**
 * Server setting to prevent updating the configuration files.
 * 
 * @ingroup server_settings
 */
define('SERVER_SETTING_HTTP_STATIC', 'http-no-refresh');

/**
 * String token for when there is no template file defined.
 * 
 * @ingroup strings
 */
define('STRING_HTTP_MISSING_TEMPLATE', 'http_config.error.no-template');

/**
 * String token for when there is no configuration.
 * 
 * @ingroup strings
 */
define('STRING_HTTP_NO_CONFIG', 'http_config.error.no-config');

/**
 * String token for when the configuration could not be written to the server.
 * 
 * @ingroup strings
 */
define('STRING_HTTP_BAD_WRITE', 'http_config.error.bad-write');

/**
 * String token for when all HTTP servers are about to be restarted.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_HTTP_RESTART', 'http_config.working.restart');

/**
 * String token for when a specific HTTP server is about to be restarted.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_HTTP_RESTART_SERVER', 'http_config.working.restart-server');

/**
 * String token for when all HTTP servers have been restarted.
 * 
 * @ingroup strings
 */
define('STRING_SUCCESS_HTTP_RESTART', 'http_config.success.restart');

/**
 * String token for when all HTTP servers are about to be configured.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_HTTP_CONFIGURE', 'http_config.working.configure');

/**
 * String token for when a specific HTTP server is about to be configured.
 * 
 * @ingroup strings
 */
define('STRING_WORKING_HTTP_CONFIGURE_SERVER', 'http_config.working.configure-server');

/**
 * String token fro when all HTTP servers have been configured.
 * 
 * @ingroup strings
 */
define('STRING_SUCCESS_HTTP_CONFIGURE', 'http_config.success.configure');

/**
 * Plugin to manage configuring the HTTP server for the Drupal install.
 */
class HttpConfigurationPlugin extends GenericPlugin implements EventListener, ServerInteractionDependency {

  /**
   * The dependency injection variable for server interaction.
   * 
   * @var ServerInteractionManagerInterface
   */
  private $servers;
  
  public function setServerManager(ServerInteractionManagerInterface $servers) {
    $this->servers = $servers;
  }
  
  public function servers() {
    return $this->servers;
  }
  
  public function initialize() {
    $this->events()->registerListener(array(
      EVENT_UPDATE_REFRESH_SERVER_CONFIG,
      EVENT_CAST_HTTP_SERVER,
      EVENT_SITE_BUILD_CONFIGURE_SERVER,
      EVENT_UPDATE_PREPARE_SERVER,
      EVENT_SUBSITE_BUILD_PARENT_SERVER_REFRESH,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_HTTP_STATIC_CONFIG => FALSE,
      CONFIG_HTTP_USE_LOCAL => TRUE,
      CONFIG_HTTP_DEFAULT_SERVER_TYPE => '',
      CONFIG_HTTP_DEFAULT_CONFIG_TEMPLATE => '',
      CONFIG_HTTP_DEFAULT_FILENAME_TEMPLATE => '@@BUILD_NAME',
      CONFIG_SERVER_LIST => array(
        SERVER_TYPE_HTTP => array(),
      ),
    ));
  }
  
  public function captureEvent(DtkEvent &$context, $eventType) {
    switch ($eventType) {
      case EVENT_SUBSITE_BUILD_PARENT_SERVER_REFRESH:
      case EVENT_SITE_BUILD_CONFIGURE_SERVER:
        if ($context->checkExecution()) {
          $context->setResult($this->publishConfig($context->getSite()));
        }
        break;
      case EVENT_UPDATE_REFRESH_SERVER_CONFIG:
        if ($context->checkExecution()) {
          $context->setResult($this->updateAll($context->getSite()));
        }
        break;
      case EVENT_UPDATE_PREPARE_SERVER:
        if ($context->checkExecution()) {
          $context->setResult($this->restartAll());
        }
        break;
      case EVENT_CAST_HTTP_SERVER:
        if ($context->checkExecution()) {
          $context->setCastedServer($this->castServer($context->getServer(), $context->getType()));
        }
        break;
    }
  }
  
  /**
   * Updates all the configuration files.
   * 
   * @param DrupalSite $site
   *   The site to update configuration files for.
   * 
   * @return boolean
   *   TRUE if all the files were updated successfully, otherwise FALSE.
   */
  private function updateAll(DrupalSite $site) {
    if (extra_empty($this->config()->getConfig(CONFIG_HTTP_STATIC_CONFIG))) {
      return $this->publishConfig($site, TRUE);
    }
    // TRUE indicates that we successfully did nothing in this case.
    return TRUE;
  }
  
  /**
   * Retrieves all of the HTTP servers registered.
   * 
   * @return array
   *   An array of HttpServerInterface
   */
  private function getAllHttpServers() {
    $config = $this->getConfig(array(
      'server_type' => CONFIG_HTTP_DEFAULT_SERVER_TYPE,
    ), array(
      'use_local' => CONFIG_HTTP_USE_LOCAL,
    ));
    if (empty($config)) {
      return array();
    }
    return $this->servers()->getServerList(
        SERVER_TYPE_HTTP,
        EVENT_CAST_HTTP_SERVER,
        SERVER_SETTING_HTTP_TYPE,
        $config['server_type'],
        !extra_empty($config['use_local'])
    );
  }
  
  
  /**
   * Restarts all the servers.
   * 
   * @return boolean
   *   TRUE. Will eventually return FALSE if there is an error rebooting
   *   a server.
   */
  private function restartAll() {
    $this->working(STRING_WORKING_HTTP_RESTART);
    $servers = $this->getAllHttpServers();
    foreach ($servers as $key => $httpServer) {
      if ($httpServer instanceof HttpServerInterface) {
        $this->working(STRING_WORKING_HTTP_RESTART_SERVER, array(
          '!name' => $key,
        ));
        $httpServer->doReboot();
      }
    }
    $this->working(STRING_SUCCESS_HTTP_RESTART);
    return TRUE;
  }
  
  /**
   * Publishes the HTTP server configuration where its needed.
   * 
   * @param DrupalSite $site
   *   The site to publish configuration for.
   * @param boolean $update
   *   Whether or not this is an update operation.
   * 
   * @return boolean
   *   TRUE if the configuration was all updated successfully, otherwise
   *   FALSE.
   */
  private function publishConfig(DrupalSite $site, $update = FALSE) {
    $this->working(STRING_WORKING_HTTP_CONFIGURE);
    $c = $this->getConfig(array(), array(
      'template' => CONFIG_HTTP_DEFAULT_CONFIG_TEMPLATE,
      'fn_template' => CONFIG_HTTP_DEFAULT_FILENAME_TEMPLATE,
    ));
    if (!is_readable($c['template'])) { $c['template'] = NULL; }
    $httpRegistry = array();
    $servers = $this->getAllHttpServers();
    $ret = TRUE;
    foreach ($servers as $key => $httpServer) {
      if ($httpServer instanceof GenericHttpServer) {
        if ($update) {
          // Check if we should be updating the config files.
          if (!extra_empty($httpServer->machine()->getSetting(SERVER_SETTING_HTTP_STATIC))) {
            continue;
          }
        }
        $this->working(STRING_WORKING_HTTP_CONFIGURE_SERVER, array(
          '!name' => $key,
        ));
        $files = $this->writeHttpConfiguration($site, $httpServer, $c);
        if (empty($files)) {
          $ret = FALSE;
        }
        else {
          foreach ($files as $x) {
            $httpRegistry[] = array(
              'file' => $x,
              'server' => $httpServer->machine(),
            );
          }
        }
      }
    }
    $site->appendSettingValue(SITE_REMOTE_FILES, $httpRegistry);
    if ($ret) {
      $this->success(STRING_SUCCESS_HTTP_CONFIGURE);
    }
    return $ret;
  }
  
  /**
   * Writes HTTP configuration a server.
   * 
   * @param DrupalSite $site
   *   The drupal site for token replacement.
   * @param HttpServerInterface $httpServer
   *   The server to write files to.
   * @param array $c
   *   Base configuration.
   * 
   * @return array
   *   An array of server files if successful, otherwise FALSE.
   */
  private function writeHttpConfiguration(DrupalSite $site, HttpServerInterface $httpServer, $c) { 
    $rawconfigFile = $httpServer->machine()->getSetting(SERVER_SETTING_HTTP_CONFIG_TEMPLATE);
    if (empty($rawconfigFile)) { 
      $rawconfigFile = $c['template']; 
    }
    if (!is_readable($rawconfigFile)) {
      $this->error(STRING_HTTP_NO_CONFIG);
      return FALSE;
    }
    $rawfilename = $httpServer->machine()->getSetting(SERVER_SETTING_HTTP_FILE_TEMPLATE);
    if (empty($rawfilename)) {
      $rawfilename = $c['fn_template'];
      if (empty($rawfilename)) {
        $this->error(STRING_HTTP_MISSING_TEMPLATE);
        return FALSE;
      }
    }
    $filename = $site->replaceTokens($rawfilename);
    $configFile = $site->replaceTokens(file_get_contents($rawconfigFile));
    if (empty($configFile)) {
      $this->error(STRING_HTTP_NO_CONFIG);
      return FALSE;
    }
    if (!$httpServer->writeConfig($filename, $configFile)) {
      $this->error(STRING_HTTP_BAD_WRITE);
      return FALSE;
    }
    $httpServer->doReboot();
    $files = $httpServer->extraFiles($filename);
    $files[] = $httpServer->getConfigFilePath($filename);
    return $files;
  }
  
  /**
   * Casts a server into an HTTP type.
   * 
   * @param PhysicalServerInterface $server
   *   The physical server object
   * @param string $type
   *   The HTTP type, see @ref http_types "HTTP Server Types"
   * 
   * @return HttpServerInterface
   *   An appropriate server interface, or NULL if none could be found.
   */
  private function castServer(PhysicalServerInterface $server, $type) {
    switch ($type) {
      case HTTP_TYPE_APACHE2:
        return new Apache2Server($server);
      case HTTP_TYPE_HTTPD:
        return new HttpdServer($server);
      case HTTP_TYPE_NGINX:
        return new NginxServer($server);
      default:
        return NULL;
    }
  }
  
}
