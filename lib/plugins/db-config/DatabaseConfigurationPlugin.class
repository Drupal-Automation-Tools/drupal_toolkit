<?php
/**
 * @file Defines the DatabaseConfigurationPlugin
 * 
 * @defgroup db_settings Database Host Settings
 * The host settings for database servers.
 * 
 * @defgroup db_types Database Type Keys
 * The keys that can be used for database servers.
 * 
 * @defgroup db_typedefs Database Types
 * Implementations of DatabaseManagerInterface.
 */

/**
 * DB server type constant for MySQL servers.
 * 
 * @ingroup db_types
 */
define('DB_SERVER_TYPE_MYSQL', 'mysql');

/**
 * Event to cast a DB server based on its type.
 * 
 * This event is fired when we want to convert an array of settings into
 * an instance of DatabaseManagerInterface. Listeners can check whether or 
 * not they support the specified type and, if so, return the appropriate
 * DatabaseManagerInterface object and stop propagation.
 * 
 * Context object properties:
 * - @c dbServer: This should be set to the appropriate DatabaseManagerInterface
 *   when found.
 * - @c type: The type name, see @ref db_types "Database Type Keys".
 * - @c settings: The settings array, which should be passed to the implementing
 *   object so it can act on it. See @ref db_settings "Database Host Settings"
 *   for available settings (not every type uses every setting).
 * 
 * 
 * @see DatabaseConfigurationPlugin::getCastedDBServer()
 * 
 * @ingroup events
 */
define('EVENT_CAST_DB_SERVER', 'cast-db-server');

/**
 * Event to find DB servers.
 * 
 * This event is fired to allow plugins to provide any DB servers. 
 * 
 * Context object properties:
 * - @c servers: An array of DatabaseManagerInterface objects. Plugins should
 *   add to this array.
 * 
 * @see DatabaseConfigurationPlugin::createDatabase().
 * 
 * @ingroup events
 */
define('EVENT_FIND_DB_SERVERS', 'find-db-servers');

/**
 * Random password constant.
 */
define('DB_RANDOM_PASSWORD', '__RANDOM__');

/**
 * Argument to specify the database name.
 * 
 * It should be a valid database name string. If not provided, the pattern
 * defined by CONFIG_SITE_NAME_PATTERN will be used.
 * 
 * @ingroup args
 */
define('ARG_DB_NAME', 'db-name');

/**
 * Argument to specify the database username.
 * 
 * It should be a valid database username. If not provided, the pattern defined
 * by CONFIG_SITE_USER_PATTERN will be used.
 * 
 * @ingroup args
 */
define('ARG_DB_USER', 'db-user');

/**
 * Argument to specify the database password.
 * 
 * It should be a valid database password. If not provided, the default defined
 * by CONFIG_DB_DEFAULT_PASSWORD will be used.
 * 
 * @ingroup args
 */
define('ARG_DB_PASSWORD', 'db-pass');

/**
 * The pattern to use for the DB username.
 * 
 * @see DrupalSite::replaceTokens().
 * 
 * @ingroup config
 */
define('CONFIG_SITE_DB_USER_PATTERN', 'site-db-username-pattern');

/**
 * The pattern to use for the DB name.
 * 
 * @see DrupalSite::replaceTokens().
 * 
 * @ingroup config
 */
define('CONFIG_SITE_DB_NAME_PATTERN', 'site-db-name-pattern');

/**
 * A host restriction for the created user.
 * 
 * @ingroup config
 */
define('CONFIG_SITE_DB_HOST_RESTRICTION', 'site-db-host-limit');

/**
 * The default server type to use.
 * 
 * This is used in the default implementation of EVENT_CAST_DB_SERVER in
 * case a type is not provided by the host configuration.
 * 
 * @see @ref db_types "Database Types"
 * @ingroup config
 */
define('CONFIG_DB_DEFAULT_TYPE', 'db-default-server-type');

/**
 * The default password to use.
 * 
 * For a random password, set to the value of DB_RANDOM_PASSWORD.
 * 
 * @ingroup config
 */
define('CONFIG_DB_DEFAULT_PASSWORD', 'db-default-new-password');

/**
 * Config key for the default database prefix to use.
 * 
 * @ingroup config
 */
define('CONFIG_DB_PREFIX', 'db-prefix');

/**
 * Command line long option to override the database prefix.
 * 
 * @ingroup args
 */
define('OPTION_DB_PREFIX', 'db-prefix');

/**
 * The list of database servers.
 * 
 * This is used for the default implementation of EVENT_FIND_DB_SERVERS.
 * 
 * @ingroup config
 */
define('CONFIG_DB_SERVERS', 'db-servers');

/**
 * The key within each DB host for its server type.
 * 
 * @ingroup db_settings
 */
define('DB_HOST_TYPE', 'type');

/**
 * The host key for the host information.
 * 
 * @ingroup db_settings
 */
define('DB_HOST_HOST', 'host');

/**
 * The host key for which server category this falls into for Drupal.
 * 
 * This is the first key of the $databases array in Drupal's settings.php.
 * 
 * @ingroup db_settings
 */
define('DB_HOST_DRUPAL_CATEGORY', 'drupal-category');

/**
 * The host key for which server mode this server plays in its category.
 * 
 * This is the second key of the $databases array in Drupal's settings.php. See 
 * DB_HOST_DRUPAL_CATEGORY for the first key.
 * 
 * @ingroup db_settings
 */
define('DB_HOST_DRUPAL_MODE', 'drupal-mode');

/**
 * The host key for the user name.
 * 
 * @ingroup db_settings
 */
define('DB_HOST_USER', 'user');

/**
 * Site setting for the list of databases that were created for it.
 * 
 * @ingroup site_settings
 */
define('SITE_DATABASE_LIST', 'db-list');

/**
 * The host key for the password.
 * 
 * @ingroup db_settings
 */
define('DB_HOST_PASSWORD', 'password');

/**
 * String token for when the database could not be created.
 * 
 * @ingroup strings
 */
define('STRING_CANNOT_CREATE_DB', 'db_config.error.cannot-create-db');
  
/**
 * String token for when the settings.php file cnanot be updated.
 * 
 * @ingroup strings
 */
define('STRING_CANNOT_WRITE_SETTINGS', 'db_config.error.cannot-write-settings');

/**
 * String token for when support for a DB type already used is removed.
 * 
 * @ingroup strings
 */
define('STRING_UNABLE_TO_USE_DB', 'db_config.error.cannot-cast-db');

/**
 * String token for when the database could not be deleted.
 * 
 * @ingroup strings
 */
define('STRING_UNABLE_TO_DELETE_DB', 'db_config.error.cannot-delete-db');

/**
 * String token for when the user could not be deleted.
 * 
 * @ingroup strings
 */
define('STRING_UNABLE_TO_DELETE_USER', 'db_config.error.cannot-delete-user');

/**
 * Site setting for all the Drupal DB connection keys.
 * 
 * @ingroup site_settings
 */
define('SITE_DB_CONNECTION_KEYS', 'db-connection-keys');

/**
 * This plugin manages the database for a Drupal site.
 * 
 * @ingroup plugins
 */
class DatabaseConfigurationPlugin extends GenericPlugin implements EventListener {
  
  public function initialize() {
    $base = dirname(__FILE__);
    require assemble_path($base, 'DatabaseManagerInterface.iface');
    require assemble_path($base, 'GenericDBM.class');
    require assemble_path($base, 'MySqlDBM.class');
    $this->events()->registerListener(array(
      EVENT_SITE_BUILD_MORE_CONFIG,
      EVENT_CAST_DB_SERVER,
      EVENT_FIND_DB_SERVERS,
      EVENT_REMOVE_ALL,
      EVENT_SUBSITE_BUILD_SERVER_CONFIG,
    ), $this);
    $this->config()->extendDefaultConfiguration(array(
      CONFIG_SITE_DB_USER_PATTERN => '@@BUILD_NAME',
      CONFIG_SITE_DB_NAME_PATTERN => '@@BUILD_NAME',
      CONFIG_SITE_DB_HOST_RESTRICTION => 'localhost',
      CONFIG_DB_DEFAULT_TYPE => '',
      CONFIG_DB_DEFAULT_PASSWORD => DB_RANDOM_PASSWORD,
      CONFIG_DB_SERVERS => array(),
      CONFIG_DB_PREFIX => '',
    ));
    $this->config()->extendFromOption(CONFIG_DB_PREFIX, OPTION_DB_PREFIX);
  }
  
  public function requiredPlugins() {
    return array('DrupalSitePlugin');
  }
  
  public function captureEvent(&$context, $type) {
    switch ($type) {
      case EVENT_SUBSITE_BUILD_SERVER_CONFIG:
        if (empty($context->handled) || $context->success) {
          $context->success = $this->createDatabase($context->subsite);
          $context->handled = TRUE;
        }
        break;
      case EVENT_SITE_BUILD_MORE_CONFIG:
        if ($context->success) {
          $context->success = $this->createDatabase($context->site);
        }
        break;
      case EVENT_CAST_DB_SERVER:
        $server = $this->castDatabaseServer($context->settings, $context->type);
        if (!empty($server)) {
          $context->dbServer = $server;
          $context->stopPropagation = TRUE;
        }
        break;
      case EVENT_FIND_DB_SERVERS:
        $context->servers = array_merge($context->servers, $this->getDatabaseServers());
        break;
      case EVENT_REMOVE_ALL:
        $context->success = $this->deleteDatabases($context->site) && $context->success;
        break;
    }
  }
  
  /**
   * Responsible for deleting all the databases and users created for this
   * site.
   * 
   * @param DrupalSite $site
   *   The site to delete databases for.
   * 
   * @return boolean
   *   TRUE if all the databases/users were deleted, or FALSE if even one had
   *   an error.
   */
  private function deleteDatabases(DrupalSite $site) {
    $servers = $site->getSetting(SITE_DATABASE_LIST);
    $ret = TRUE;
    foreach ($servers as $serverData) {
      $server = $this->castDatabaseServer($serverData['dbSettings'], $serverData['type']);
      if ($server instanceof DatabaseManagerInterface) {
        if (!$server->deleteDatabase($serverData['database'])) {
          $this->warn(STRING_UNABLE_TO_DELETE_DB, array(
            '!name' => $serverData['database'],
          ));
          $ret = FALSE;
        }
        if (!$server->deleteUser($serverData['username'], $serverData['host'])) {
          $this->warn(STRING_UNABLE_TO_DELETE_USER, array(
            '!name' => $serverData['username'],
          ));
          $ret = FALSE;
        }
      }
      else {
        $this->warn(STRING_UNABLE_TO_USE_DB, array(
          '!type' => $serverData['type'],
        ));
        $ret = FALSE;
      }
    }
    return $ret;
  }
  
  /**
   * Callback for site-build-additional-config that creates a database.
   * 
   * @see DrupalSiteBuildPlugin
   * 
   * @param GenericDrupalEntity $site
   *   The site or subsite we're configuring
   * 
   * @return
   */
  private function createDatabase(GenericDrupalEntity $site) {
    $context = (object) array(
      'servers' => array(),
    );
    $host = $this->config()->getConfig(CONFIG_SITE_DB_HOST_RESTRICTION);
    if (empty($host)) {
      $host = NULL;
    }
    $this->events()->fireEvent(EVENT_FIND_DB_SERVERS, $context);
    $username = $this->args()->getOption(ARG_DB_USER);
    if (empty($username)) {
      $username = $site->replaceTokens($this->config()->getConfig(CONFIG_SITE_DB_USER_PATTERN));
    }
    $dbname = $this->args()->getOption(ARG_DB_NAME);
    if (empty($dbname)) {
      $dbname = $site->replaceTokens($this->config()->getConfig(CONFIG_SITE_DB_NAME_PATTERN));
    }
    $dbpass = $this->args()->getOption(ARG_DB_PASSWORD);
    if (empty($dbpass)) {
      $dbpass = $this->config()->getConfig(CONFIG_DB_DEFAULT_PASSWORD);
    }
    $prefix = $this->config()->getConfig(CONFIG_DB_PREFIX);
    $drupalSettings = array();
    $dbStorage = array();
    $connectionKeys = array();
    foreach ($context->servers as $server) {
      if ($server instanceof DatabaseManagerInterface) {
        $dbname = $server->sanitizeDatabaseName($dbname);
        $username = $server->sanitizeUsername($username);
        if ($dbpass == DB_RANDOM_PASSWORD) {
          $dbpass = $server->randomPassword();
        }
        $dbStorage[] = array(
          'type' => $server->getSetting(DB_HOST_TYPE),
          'dbSettings' => $server->getSettings(),
          'username' => $username,
          'database' => $dbname,
          'host' => $host,
        );
        $connectionKeys[$server->getDatabaseCategory()] = $server->getDatabaseCategory();
        $drupalSettings[$server->getDatabaseCategory()][$server->getDatabaseMode()] = array(
          'driver' => $server->getDriver(),
          'database' => $dbname,
          'username' => $username,
          'password' => $dbpass,
          'host' => $server->getHost(),
          'prefix' => extra_empty($prefix) ? '' : $prefix,
        );
      }
    }
    foreach ($context->servers as $server) {
      if ($server instanceof DatabaseManagerInterface) {
        if (!$server->createDatabase($dbname, $username, $dbpass, $host)) {
          $this->error(STRING_CANNOT_CREATE_DB);
          return FALSE;
        }
      }
    }
    if (!$this->writeDatabaseSettings($site, $drupalSettings)) {
      $this->error(STRING_CANNOT_WRITE_SETTINGS);
      return FALSE;
    }
    $site->setSetting(SITE_DB_CONNECTION_KEYS, $connectionKeys);
    $site->setSetting(SITE_DATABASE_LIST, $dbStorage);
    return TRUE;
  }
  
  /**
   * Converts the database settings array to a string for output.
   * 
   * @param array $settings
   *   A database settings array.
   * 
   * @return string
   *   A valid PHP statement to recreate the database settings.
   */
  private function convertSettingsToString(array $settings) {
    $str = '';
    $str = '$databases = array(' . PHP_EOL;
    foreach ($settings as $dbcat => $dbs) {
      $str .= '  "' . $dbcat . '" => array(' . PHP_EOL;
      foreach ($dbs as $dbmode => $db) {
        $str .= '    "' . $dbmode . '" => array(' . PHP_EOL;
        foreach ($db as $key => $value) {
          $str .= '      "' . $key . '" => "' . $value . '",' . PHP_EOL;
        }
        $str .= '  ),' . PHP_EOL;
      }
      $str .= '),' . PHP_EOL;
    }
    $str .= ');';
    return $str;
  }
  
  /**
   * Writes the database settings to the settings.php file for the site.
   * 
   * @param GenericDrupalEntity $site
   *   The site to write settings for.
   * @param array $dbSettings
   *   The database settings to write.
   * 
   * @return boolean
   *   TRUE if successful, otherwise false.
   * 
   * @see DatabaseConfigurationPlugin::convertSettingsToString()
   */
  private function writeDatabaseSettings(GenericDrupalEntity $site, array $dbSettings) {
    $settingsFile = $site->getSetting(SITE_SETTINGS_FILE);
    if (empty($settingsFile)) {
      return FALSE;
    }
    if (!is_writable($settingsFile)) {
      return FALSE;
    }
    $h = fopen($settingsFile, 'a');
    if (empty($h)) {
      return FALSE;
    }
    if (!fwrite($h, $this->convertSettingsToString($dbSettings))) {
      fclose($h);
      return FALSE;
    }
    fclose($h);
    return TRUE;
  }
  
  /**
   * Creates a DatabaseManagerInterface object around the settings. 
   * 
   * @param array $settings
   *   The settings array.
   * @param string $type
   *   The type of server.
   * 
   * @return DatabaseManagerInterface
   *   A database manager, or NULL if the type was not recognized.
   */
  private function castDatabaseServer($settings, $type) {
    switch ($type) {
      case DB_SERVER_TYPE_MYSQL:
        return new MySqlDBM($settings);
    }
    return NULL;
  }
  
  /**
   * Retrieves a list of database servers.
   * 
   * @return array
   *   An array of DatabaseManagerInterface objects.
   */
  private function getDatabaseServers() {
    $defaultType = $this->config()->getConfig(CONFIG_DB_DEFAULT_TYPE);
    $servers = $this->config()->getConfig(CONFIG_DB_SERVERS);
    $dbServers = array();
    foreach ($servers as $server) {
      $type = isset($server[DB_HOST_TYPE]) ? $server[DB_HOST_TYPE] : $defaultType;
      $server[DB_HOST_TYPE] = $type;
      $dbServer = $this->getCastedDBServer($server, $type);
      if ($dbServer instanceof DatabaseManagerInterface) {
        if ($dbServer->available()) {
          $dbServers[] = $dbServer;
        }
      }
    }
    return $dbServers;
  }
  
  /**
   * Casts the server settings into a DatabaseManagerInterface object.
   * 
   * @param array $settings
   *   An array of settings.
   * @param string $type
   *   The detected type of the server.
   * 
   * @return DatabaseManagerInterface
   *   An instance of DatabaseManagerInterface corresponding to $type or NULL
   *   if none was found.
   */
  private function getCastedDBServer($settings, $type) {
    $context = (object) array(
      'type' => $type,
      'settings' => $settings,
      'dbServer' => NULL,
    );
    $this->events()->fireEvent(EVENT_CAST_DB_SERVER, $context);
    return $context->dbServer;
  }
  
}
